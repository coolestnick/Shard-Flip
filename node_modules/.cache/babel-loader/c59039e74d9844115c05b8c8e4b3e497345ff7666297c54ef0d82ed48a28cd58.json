{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport { contractService } from '../services/contractService';\nimport { apiService } from '../services/apiService';\nimport { useWeb3 } from '../contexts/Web3Context';\nimport { REFRESH_INTERVAL } from '../utils/constants';\nexport const useGameData = () => {\n  _s();\n  const {\n    wallet,\n    provider,\n    signer\n  } = useWeb3();\n  const [recentGames, setRecentGames] = useState([]);\n  const [playerStats, setPlayerStats] = useState(null);\n  const [gameStats, setGameStats] = useState(null);\n  const [leaderboard, setLeaderboard] = useState([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState(null);\n  const [lastUpdate, setLastUpdate] = useState(new Date());\n\n  // Initialize contract service when web3 is ready\n  useEffect(() => {\n    if (provider && signer) {\n      contractService.initialize(provider, signer);\n    }\n  }, [provider, signer]);\n  const fetchRecentGames = useCallback(async () => {\n    try {\n      const games = await contractService.getRecentGames(50);\n      setRecentGames(games);\n    } catch (error) {\n      console.error('Error fetching recent games:', error);\n    }\n  }, []);\n  const fetchPlayerStats = useCallback(async () => {\n    if (!wallet.address) {\n      setPlayerStats(null);\n      return;\n    }\n    try {\n      const stats = await contractService.getPlayerStats(wallet.address);\n      setPlayerStats(stats);\n    } catch (error) {\n      console.error('Error fetching player stats:', error);\n    }\n  }, [wallet.address]);\n  const fetchGameStats = useCallback(async () => {\n    try {\n      const stats = await contractService.getGameStats();\n      setGameStats(stats);\n    } catch (error) {\n      console.error('Error fetching game stats:', error);\n    }\n  }, []);\n  const fetchLeaderboard = useCallback(async () => {\n    try {\n      const board = await contractService.getLeaderboard(10);\n      setLeaderboard(board);\n    } catch (error) {\n      console.error('Error fetching leaderboard:', error);\n    }\n  }, []);\n  const refreshAllData = useCallback(async (showLoading = true) => {\n    if (!contractService.isInitialized()) return;\n    if (showLoading) setIsLoading(true);\n    setError(null);\n    try {\n      await Promise.all([fetchRecentGames(), fetchPlayerStats(), fetchGameStats(), fetchLeaderboard()]);\n      setLastUpdate(new Date());\n    } catch (error) {\n      setError(error.message || 'Failed to fetch data');\n      console.error('Error refreshing data:', error);\n    } finally {\n      if (showLoading) setIsLoading(false);\n    }\n  }, [fetchRecentGames, fetchPlayerStats, fetchGameStats, fetchLeaderboard]);\n\n  // Initial data fetch\n  useEffect(() => {\n    if (contractService.isInitialized()) {\n      refreshAllData();\n    }\n  }, [refreshAllData]);\n\n  // Auto-refresh data (background refresh without loading indicators)\n  useEffect(() => {\n    if (!contractService.isInitialized()) return;\n    const interval = setInterval(() => {\n      refreshAllData(false); // Silent refresh without loading spinner\n    }, REFRESH_INTERVAL);\n    return () => clearInterval(interval);\n  }, [refreshAllData]);\n\n  // Set up event listeners for real-time updates\n  useEffect(() => {\n    if (!contractService.isInitialized()) return;\n    const cleanup = contractService.setupEventListeners(newGame => {\n      setRecentGames(prev => [newGame, ...prev.slice(0, 49)]);\n\n      // Refresh stats when new game is played\n      if (wallet.address) {\n        fetchPlayerStats();\n        fetchGameStats();\n      }\n    });\n    return cleanup;\n  }, [wallet.address, fetchPlayerStats, fetchGameStats]);\n  return {\n    recentGames,\n    playerStats,\n    gameStats,\n    leaderboard,\n    isLoading,\n    error,\n    lastUpdate,\n    refreshData: refreshAllData,\n    refreshPlayerStats: fetchPlayerStats\n  };\n};\n_s(useGameData, \"WwrlYc82Dw8fhQehF05OYEODpd0=\", false, function () {\n  return [useWeb3];\n});\nexport const useGameActions = () => {\n  _s2();\n  const {\n    wallet,\n    refreshBalance\n  } = useWeb3();\n  const [isFlipping, setIsFlipping] = useState(false);\n  const [lastResult, setLastResult] = useState(null);\n  const flipCoin = useCallback(async (amount, choice) => {\n    if (!contractService.isInitialized()) {\n      throw new Error('Contract not initialized');\n    }\n    if (!wallet.isConnected || !wallet.address) {\n      throw new Error('Wallet not connected');\n    }\n    setIsFlipping(true);\n    try {\n      // First, register that the user is playing (immediate feedback)\n      console.log('🎮 Player starting game:', wallet.address);\n      const result = await contractService.flipCoin(amount, choice);\n      if (result.success) {\n        // Wait for transaction confirmation and get result\n        if (result.txHash) {\n          try {\n            const confirmed = await contractService.waitForTransaction(result.txHash);\n            if (confirmed) {\n              // The actual result would come from contract events\n              // For now, we'll simulate it (in real implementation, parse from events)\n              const coinResult = Math.random() < 0.5 ? 'heads' : 'tails';\n              setLastResult(coinResult);\n\n              // IMPORTANT: Always update backend after successful flip\n              try {\n                console.log('🎯 Directly updating backend after successful flip');\n                const betAmountNum = parseFloat(amount);\n                const won = coinResult === choice;\n                const updateResult = await apiService.updateGameResult(wallet.address, won ? 'win' : 'loss', betAmountNum, won ? betAmountNum * 2 : 0);\n                console.log('✅ Backend updated successfully:', updateResult);\n              } catch (apiError) {\n                console.error('❌ Failed to update backend directly:', apiError);\n              }\n            } else {\n              console.warn('⚠️ Transaction confirmation failed or timed out');\n            }\n          } catch (waitError) {\n            console.error('❌ Error waiting for transaction confirmation:', waitError);\n            // Continue execution even if waiting failed - transaction might still be successful\n          }\n        }\n\n        // Refresh balance after successful transaction\n        try {\n          await refreshBalance();\n        } catch (refreshError) {\n          console.error('❌ Error refreshing balance:', refreshError);\n          // Don't throw - this is not critical\n        }\n        return result;\n      } else {\n        throw new Error(result.error || 'Transaction failed');\n      }\n    } catch (error) {\n      console.error('❌ Error in flipCoin:', error);\n      throw error;\n    } finally {\n      // CRITICAL: Always reset the flipping state, no matter what happens\n      console.log('🔄 Resetting flipping state...');\n      setIsFlipping(false);\n    }\n  }, [wallet.isConnected, wallet.address, refreshBalance]);\n  const resetFlippingState = useCallback(() => {\n    console.log('🔄 Manually resetting flipping state...');\n    setIsFlipping(false);\n    setLastResult(null);\n  }, []);\n  return {\n    flipCoin,\n    isFlipping,\n    lastResult,\n    clearLastResult: () => setLastResult(null),\n    resetFlippingState\n  };\n};\n\n// Hook for managing sound effects\n_s2(useGameActions, \"dlWH+2fYLQlVsaNps/q7e5B2fxI=\", false, function () {\n  return [useWeb3];\n});\nexport const useSounds = () => {\n  _s3();\n  const [soundEnabled, setSoundEnabled] = useState(() => {\n    const stored = localStorage.getItem('soundEnabled');\n    return stored ? JSON.parse(stored) : true;\n  });\n  const [volume, setVolume] = useState(() => {\n    const stored = localStorage.getItem('soundVolume');\n    return stored ? parseFloat(stored) : 0.5;\n  });\n  useEffect(() => {\n    localStorage.setItem('soundEnabled', JSON.stringify(soundEnabled));\n  }, [soundEnabled]);\n  useEffect(() => {\n    localStorage.setItem('soundVolume', volume.toString());\n  }, [volume]);\n  const playSound = useCallback(soundName => {\n    if (!soundEnabled) return;\n    try {\n      const audio = new Audio(`/sounds/${soundName}.mp3`);\n      audio.volume = volume;\n      audio.play().catch(console.error);\n    } catch (error) {\n      console.error('Error playing sound:', error);\n    }\n  }, [soundEnabled, volume]);\n  return {\n    soundEnabled,\n    setSoundEnabled,\n    volume,\n    setVolume,\n    playSound\n  };\n};\n\n// Hook for managing app settings\n_s3(useSounds, \"2OdXDYY2lw8ctPZa8+P7E4ZGRHo=\");\nexport const useSettings = () => {\n  _s4();\n  const [settings, setSettings] = useState(() => {\n    const stored = localStorage.getItem('gameSettings');\n    return stored ? JSON.parse(stored) : {\n      sound: {\n        enabled: true,\n        volume: 0.5\n      },\n      autoRefresh: true,\n      refreshInterval: REFRESH_INTERVAL,\n      showAnimations: true\n    };\n  });\n  useEffect(() => {\n    localStorage.setItem('gameSettings', JSON.stringify(settings));\n  }, [settings]);\n  const updateSettings = useCallback(updates => {\n    setSettings(prev => ({\n      ...prev,\n      ...updates\n    }));\n  }, []);\n  return {\n    settings,\n    updateSettings\n  };\n};\n_s4(useSettings, \"FRNB5Ymr9b8McX/ZOm+bH9nrPmc=\");","map":{"version":3,"names":["useState","useEffect","useCallback","contractService","apiService","useWeb3","REFRESH_INTERVAL","useGameData","_s","wallet","provider","signer","recentGames","setRecentGames","playerStats","setPlayerStats","gameStats","setGameStats","leaderboard","setLeaderboard","isLoading","setIsLoading","error","setError","lastUpdate","setLastUpdate","Date","initialize","fetchRecentGames","games","getRecentGames","console","fetchPlayerStats","address","stats","getPlayerStats","fetchGameStats","getGameStats","fetchLeaderboard","board","getLeaderboard","refreshAllData","showLoading","isInitialized","Promise","all","message","interval","setInterval","clearInterval","cleanup","setupEventListeners","newGame","prev","slice","refreshData","refreshPlayerStats","useGameActions","_s2","refreshBalance","isFlipping","setIsFlipping","lastResult","setLastResult","flipCoin","amount","choice","Error","isConnected","log","result","success","txHash","confirmed","waitForTransaction","coinResult","Math","random","betAmountNum","parseFloat","won","updateResult","updateGameResult","apiError","warn","waitError","refreshError","resetFlippingState","clearLastResult","useSounds","_s3","soundEnabled","setSoundEnabled","stored","localStorage","getItem","JSON","parse","volume","setVolume","setItem","stringify","toString","playSound","soundName","audio","Audio","play","catch","useSettings","_s4","settings","setSettings","sound","enabled","autoRefresh","refreshInterval","showAnimations","updateSettings","updates"],"sources":["/Users/nikhilkumar/Documents/Unstable/Shard-Flip/src/hooks/useGameData.ts"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport { GameResult, PlayerStats, GameStats, LeaderboardEntry } from '../types';\nimport { contractService } from '../services/contractService';\nimport { apiService } from '../services/apiService';\nimport { useWeb3 } from '../contexts/Web3Context';\nimport { REFRESH_INTERVAL } from '../utils/constants';\n\nexport const useGameData = () => {\n  const { wallet, provider, signer } = useWeb3();\n  const [recentGames, setRecentGames] = useState<GameResult[]>([]);\n  const [playerStats, setPlayerStats] = useState<PlayerStats | null>(null);\n  const [gameStats, setGameStats] = useState<GameStats | null>(null);\n  const [leaderboard, setLeaderboard] = useState<LeaderboardEntry[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [lastUpdate, setLastUpdate] = useState<Date>(new Date());\n\n  // Initialize contract service when web3 is ready\n  useEffect(() => {\n    if (provider && signer) {\n      contractService.initialize(provider, signer);\n    }\n  }, [provider, signer]);\n\n  const fetchRecentGames = useCallback(async () => {\n    try {\n      const games = await contractService.getRecentGames(50);\n      setRecentGames(games);\n    } catch (error) {\n      console.error('Error fetching recent games:', error);\n    }\n  }, []);\n\n  const fetchPlayerStats = useCallback(async () => {\n    if (!wallet.address) {\n      setPlayerStats(null);\n      return;\n    }\n\n    try {\n      const stats = await contractService.getPlayerStats(wallet.address);\n      setPlayerStats(stats);\n    } catch (error) {\n      console.error('Error fetching player stats:', error);\n    }\n  }, [wallet.address]);\n\n  const fetchGameStats = useCallback(async () => {\n    try {\n      const stats = await contractService.getGameStats();\n      setGameStats(stats);\n    } catch (error) {\n      console.error('Error fetching game stats:', error);\n    }\n  }, []);\n\n  const fetchLeaderboard = useCallback(async () => {\n    try {\n      const board = await contractService.getLeaderboard(10);\n      setLeaderboard(board);\n    } catch (error) {\n      console.error('Error fetching leaderboard:', error);\n    }\n  }, []);\n\n  const refreshAllData = useCallback(async (showLoading: boolean = true) => {\n    if (!contractService.isInitialized()) return;\n\n    if (showLoading) setIsLoading(true);\n    setError(null);\n\n    try {\n      await Promise.all([\n        fetchRecentGames(),\n        fetchPlayerStats(),\n        fetchGameStats(),\n        fetchLeaderboard()\n      ]);\n      setLastUpdate(new Date());\n    } catch (error: any) {\n      setError(error.message || 'Failed to fetch data');\n      console.error('Error refreshing data:', error);\n    } finally {\n      if (showLoading) setIsLoading(false);\n    }\n  }, [fetchRecentGames, fetchPlayerStats, fetchGameStats, fetchLeaderboard]);\n\n  // Initial data fetch\n  useEffect(() => {\n    if (contractService.isInitialized()) {\n      refreshAllData();\n    }\n  }, [refreshAllData]);\n\n  // Auto-refresh data (background refresh without loading indicators)\n  useEffect(() => {\n    if (!contractService.isInitialized()) return;\n\n    const interval = setInterval(() => {\n      refreshAllData(false); // Silent refresh without loading spinner\n    }, REFRESH_INTERVAL);\n\n    return () => clearInterval(interval);\n  }, [refreshAllData]);\n\n  // Set up event listeners for real-time updates\n  useEffect(() => {\n    if (!contractService.isInitialized()) return;\n\n    const cleanup = contractService.setupEventListeners((newGame) => {\n      setRecentGames(prev => [newGame, ...prev.slice(0, 49)]);\n      \n      // Refresh stats when new game is played\n      if (wallet.address) {\n        fetchPlayerStats();\n        fetchGameStats();\n      }\n    });\n\n    return cleanup;\n  }, [wallet.address, fetchPlayerStats, fetchGameStats]);\n\n  return {\n    recentGames,\n    playerStats,\n    gameStats,\n    leaderboard,\n    isLoading,\n    error,\n    lastUpdate,\n    refreshData: refreshAllData,\n    refreshPlayerStats: fetchPlayerStats\n  };\n};\n\nexport const useGameActions = () => {\n  const { wallet, refreshBalance } = useWeb3();\n  const [isFlipping, setIsFlipping] = useState(false);\n  const [lastResult, setLastResult] = useState<'heads' | 'tails' | null>(null);\n\n  const flipCoin = useCallback(async (amount: string, choice: 'heads' | 'tails') => {\n    if (!contractService.isInitialized()) {\n      throw new Error('Contract not initialized');\n    }\n\n    if (!wallet.isConnected || !wallet.address) {\n      throw new Error('Wallet not connected');\n    }\n\n    setIsFlipping(true);\n\n    try {\n      // First, register that the user is playing (immediate feedback)\n      console.log('🎮 Player starting game:', wallet.address);\n\n      const result = await contractService.flipCoin(amount, choice);\n\n      if (result.success) {\n        // Wait for transaction confirmation and get result\n        if (result.txHash) {\n          try {\n            const confirmed = await contractService.waitForTransaction(result.txHash);\n            if (confirmed) {\n              // The actual result would come from contract events\n              // For now, we'll simulate it (in real implementation, parse from events)\n              const coinResult = Math.random() < 0.5 ? 'heads' : 'tails';\n              setLastResult(coinResult);\n\n              // IMPORTANT: Always update backend after successful flip\n              try {\n                console.log('🎯 Directly updating backend after successful flip');\n                const betAmountNum = parseFloat(amount);\n                const won = coinResult === choice;\n\n                const updateResult = await apiService.updateGameResult(\n                  wallet.address!,\n                  won ? 'win' : 'loss',\n                  betAmountNum,\n                  won ? betAmountNum * 2 : 0\n                );\n\n                console.log('✅ Backend updated successfully:', updateResult);\n              } catch (apiError) {\n                console.error('❌ Failed to update backend directly:', apiError);\n              }\n            } else {\n              console.warn('⚠️ Transaction confirmation failed or timed out');\n            }\n          } catch (waitError) {\n            console.error('❌ Error waiting for transaction confirmation:', waitError);\n            // Continue execution even if waiting failed - transaction might still be successful\n          }\n        }\n\n        // Refresh balance after successful transaction\n        try {\n          await refreshBalance();\n        } catch (refreshError) {\n          console.error('❌ Error refreshing balance:', refreshError);\n          // Don't throw - this is not critical\n        }\n\n        return result;\n      } else {\n        throw new Error(result.error || 'Transaction failed');\n      }\n    } catch (error) {\n      console.error('❌ Error in flipCoin:', error);\n      throw error;\n    } finally {\n      // CRITICAL: Always reset the flipping state, no matter what happens\n      console.log('🔄 Resetting flipping state...');\n      setIsFlipping(false);\n    }\n  }, [wallet.isConnected, wallet.address, refreshBalance]);\n\n  const resetFlippingState = useCallback(() => {\n    console.log('🔄 Manually resetting flipping state...');\n    setIsFlipping(false);\n    setLastResult(null);\n  }, []);\n\n  return {\n    flipCoin,\n    isFlipping,\n    lastResult,\n    clearLastResult: () => setLastResult(null),\n    resetFlippingState\n  };\n};\n\n// Hook for managing sound effects\nexport const useSounds = () => {\n  const [soundEnabled, setSoundEnabled] = useState(() => {\n    const stored = localStorage.getItem('soundEnabled');\n    return stored ? JSON.parse(stored) : true;\n  });\n\n  const [volume, setVolume] = useState(() => {\n    const stored = localStorage.getItem('soundVolume');\n    return stored ? parseFloat(stored) : 0.5;\n  });\n\n  useEffect(() => {\n    localStorage.setItem('soundEnabled', JSON.stringify(soundEnabled));\n  }, [soundEnabled]);\n\n  useEffect(() => {\n    localStorage.setItem('soundVolume', volume.toString());\n  }, [volume]);\n\n  const playSound = useCallback((soundName: string) => {\n    if (!soundEnabled) return;\n\n    try {\n      const audio = new Audio(`/sounds/${soundName}.mp3`);\n      audio.volume = volume;\n      audio.play().catch(console.error);\n    } catch (error) {\n      console.error('Error playing sound:', error);\n    }\n  }, [soundEnabled, volume]);\n\n  return {\n    soundEnabled,\n    setSoundEnabled,\n    volume,\n    setVolume,\n    playSound\n  };\n};\n\n// Hook for managing app settings\nexport const useSettings = () => {\n  const [settings, setSettings] = useState(() => {\n    const stored = localStorage.getItem('gameSettings');\n    return stored ? JSON.parse(stored) : {\n      sound: { enabled: true, volume: 0.5 },\n      autoRefresh: true,\n      refreshInterval: REFRESH_INTERVAL,\n      showAnimations: true\n    };\n  });\n\n  useEffect(() => {\n    localStorage.setItem('gameSettings', JSON.stringify(settings));\n  }, [settings]);\n\n  const updateSettings = useCallback((updates: Partial<typeof settings>) => {\n    setSettings((prev: any) => ({ ...prev, ...updates }));\n  }, []);\n\n  return {\n    settings,\n    updateSettings\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}