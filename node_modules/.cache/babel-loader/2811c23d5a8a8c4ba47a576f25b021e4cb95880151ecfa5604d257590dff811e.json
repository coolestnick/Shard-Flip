{"ast":null,"code":"import { ethers } from 'ethers';\nimport { CONTRACT_ABI, SHARDEUM_UNSTABLE } from '../utils/constants';\nimport toast from 'react-hot-toast';\nexport class ContractService {\n  constructor(provider, signer) {\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n    if (provider && signer) {\n      this.initialize(provider, signer);\n    }\n  }\n  initialize(provider, signer) {\n    this.provider = provider;\n    this.signer = signer;\n    this.contract = new ethers.Contract(SHARDEUM_UNSTABLE.contracts.shardFlip, CONTRACT_ABI, signer);\n  }\n  isInitialized() {\n    return this.contract !== null && this.signer !== null && this.provider !== null;\n  }\n  async flipCoin(amount, choice) {\n    if (!this.isInitialized()) {\n      return {\n        success: false,\n        error: 'Contract not initialized'\n      };\n    }\n    try {\n      const betAmount = ethers.parseEther(amount);\n      const choiceBool = choice === 'heads'; // true for heads, false for tails\n\n      // Check minimum bet amount\n      const minBet = await this.contract.MIN_BET();\n      if (betAmount < minBet) {\n        throw new Error(`Minimum bet is ${ethers.formatEther(minBet)} SHM`);\n      }\n\n      // Check maximum bet amount\n      const maxBet = await this.contract.MAX_BET();\n      if (betAmount > maxBet) {\n        throw new Error(`Maximum bet is ${ethers.formatEther(maxBet)} SHM`);\n      }\n\n      // Check contract balance for potential payout\n      const contractBalance = await this.contract.getContractBalance();\n      const payoutMultiplier = await this.contract.PAYOUT_MULTIPLIER();\n      const potentialPayout = betAmount * payoutMultiplier / 100n;\n      if (contractBalance < potentialPayout) {\n        throw new Error('Contract has insufficient balance for this bet');\n      }\n\n      // Check if contract is paused\n      const isPaused = await this.contract.paused();\n      if (isPaused) {\n        throw new Error('Contract is currently paused');\n      }\n      let gasLimit;\n      try {\n        // Estimate gas with a more conservative approach\n        const gasEstimate = await this.contract.flipCoin.estimateGas(choiceBool, {\n          value: betAmount\n        });\n        gasLimit = gasEstimate * 150n / 100n; // 50% buffer\n      } catch (gasError) {\n        console.warn('Gas estimation failed, using fallback:', gasError);\n        gasLimit = 500000n; // Fallback gas limit\n      }\n\n      // Get current gas price\n      const gasPrice = await this.provider.getFeeData();\n      const tx = await this.contract.flipCoin(choiceBool, {\n        value: betAmount,\n        gasLimit: gasLimit,\n        gasPrice: gasPrice.gasPrice\n      });\n      toast.success('Transaction sent! Waiting for confirmation...');\n      const receipt = await tx.wait();\n      if (receipt && receipt.status === 1) {\n        toast.success('Coin flip completed!');\n        return {\n          success: true,\n          txHash: tx.hash\n        };\n      } else {\n        throw new Error('Transaction failed');\n      }\n    } catch (error) {\n      var _error$message, _error$message2, _error$message3, _error$message4, _error$message5;\n      console.error('Error flipping coin:', error);\n      let errorMessage = 'Failed to flip coin';\n      if (error.code === 'ACTION_REJECTED') {\n        errorMessage = 'Transaction rejected by user';\n      } else if (error.code === 'INSUFFICIENT_FUNDS') {\n        errorMessage = 'Insufficient funds for bet + gas';\n      } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        errorMessage = 'Cannot estimate gas - contract may be paused or have insufficient balance';\n      } else if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('insufficient funds')) {\n        errorMessage = 'Insufficient SHM balance';\n      } else if ((_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('Minimum bet')) {\n        errorMessage = error.message;\n      } else if ((_error$message3 = error.message) !== null && _error$message3 !== void 0 && _error$message3.includes('Maximum bet')) {\n        errorMessage = error.message;\n      } else if ((_error$message4 = error.message) !== null && _error$message4 !== void 0 && _error$message4.includes('insufficient balance')) {\n        errorMessage = error.message;\n      } else if ((_error$message5 = error.message) !== null && _error$message5 !== void 0 && _error$message5.includes('paused')) {\n        errorMessage = error.message;\n      } else if (error.code === -32603) {\n        errorMessage = 'Network error - please try again';\n      }\n      toast.error(errorMessage);\n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n  async getPlayerStats(address) {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n    try {\n      const stats = await this.contract.getPlayerStats(address);\n\n      // The contract returns individual values\n      const totalGames = Number(stats[0]);\n      const totalWins = Number(stats[1]);\n      const totalWagered = ethers.formatEther(stats[2]);\n      const totalWon = ethers.formatEther(stats[3]);\n      return {\n        totalGames,\n        totalWins,\n        winRate: totalGames > 0 ? totalWins / totalGames * 100 : 0,\n        totalWagered,\n        totalWon,\n        netProfit: (parseFloat(totalWon) - parseFloat(totalWagered)).toString()\n      };\n    } catch (error) {\n      console.error('Error fetching player stats:', error);\n      // Return default stats instead of null to prevent UI issues\n      return {\n        totalGames: 0,\n        totalWins: 0,\n        winRate: 0,\n        totalWagered: '0',\n        totalWon: '0',\n        netProfit: '0'\n      };\n    }\n  }\n  async getRecentGames(limit = 50) {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n    try {\n      const games = await this.contract.getRecentGames();\n      return games.slice(0, limit).map((game, index) => ({\n        id: `${game.player}-${game.timestamp}-${index}`,\n        player: game.player,\n        betAmount: ethers.formatEther(game.betAmount),\n        choice: game.choice ? 'heads' : 'tails',\n        result: game.result ? 'heads' : 'tails',\n        won: game.won,\n        payout: ethers.formatEther(game.payout),\n        timestamp: Number(game.timestamp),\n        txHash: '' // This would need to be tracked separately or obtained from events\n      }));\n    } catch (error) {\n      console.error('Error fetching recent games:', error);\n      return [];\n    }\n  }\n  async getGameStats() {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n    try {\n      const stats = await this.contract.getGameStats();\n\n      // The new contract returns individual values, not a struct\n      return {\n        totalGames: Number(stats[0]),\n        totalVolume: ethers.formatEther(stats[1]),\n        totalPayout: ethers.formatEther(stats[2]),\n        activeUsers: Number(stats[3])\n      };\n    } catch (error) {\n      console.error('Error fetching game stats:', error);\n      return null;\n    }\n  }\n  async getLeaderboard(limit = 10) {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n    try {\n      const [players, wins, wagered] = await this.contract.getTopPlayers(limit);\n      return players.map((player, index) => ({\n        address: player,\n        wins: Number(wins[index]),\n        totalWagered: ethers.formatEther(wagered[index]),\n        netProfit: '0',\n        // Would need additional calculation\n        winRate: 0 // Would need total games to calculate\n      }));\n    } catch (error) {\n      console.error('Error fetching leaderboard:', error);\n      return [];\n    }\n  }\n  async waitForTransaction(txHash) {\n    if (!this.provider) return false;\n    try {\n      const receipt = await this.provider.waitForTransaction(txHash, 1, 30000); // 30 second timeout\n      return receipt ? receipt.status === 1 : false;\n    } catch (error) {\n      console.error('Error waiting for transaction:', error);\n      return false;\n    }\n  }\n\n  // Utility method to parse game events (for real-time updates)\n  async parseGameEvents(fromBlock = 0) {\n    if (!this.contract || !this.provider) return [];\n    try {\n      // This would parse GamePlayed events from the contract\n      // Implementation depends on the actual contract events\n      const filter = this.contract.filters.GamePlayed();\n      const events = await this.contract.queryFilter(filter, fromBlock);\n      return events.map(event => {\n        const args = event.args;\n        return {\n          id: `${args.player}-${args.timestamp}`,\n          player: args.player,\n          betAmount: ethers.formatEther(args.betAmount),\n          choice: args.choice ? 'heads' : 'tails',\n          result: args.result ? 'heads' : 'tails',\n          won: args.won,\n          payout: ethers.formatEther(args.payout),\n          timestamp: Number(args.timestamp),\n          txHash: event.transactionHash\n        };\n      });\n    } catch (error) {\n      console.error('Error parsing game events:', error);\n      return [];\n    }\n  }\n\n  // Listen for real-time game events\n  setupEventListeners(onGamePlayed) {\n    if (!this.contract) {\n      return () => {};\n    }\n    const handleGamePlayed = (player, betAmount, choice, result, won, payout, timestamp) => {\n      const game = {\n        id: `${player}-${timestamp}`,\n        player,\n        betAmount: ethers.formatEther(betAmount),\n        choice: choice ? 'heads' : 'tails',\n        result: result ? 'heads' : 'tails',\n        won,\n        payout: ethers.formatEther(payout),\n        timestamp: Number(timestamp),\n        txHash: '' // Would be available in the event context\n      };\n      if (onGamePlayed) {\n        onGamePlayed(game);\n      }\n    };\n    try {\n      this.contract.on('GamePlayed', handleGamePlayed);\n      return () => {\n        if (this.contract) {\n          this.contract.off('GamePlayed', handleGamePlayed);\n        }\n      };\n    } catch (error) {\n      console.error('Error setting up event listeners:', error);\n      return () => {};\n    }\n  }\n  disconnect() {\n    if (this.contract) {\n      this.contract.removeAllListeners();\n    }\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n  }\n}\n\n// Singleton instance\nexport const contractService = new ContractService();","map":{"version":3,"names":["ethers","CONTRACT_ABI","SHARDEUM_UNSTABLE","toast","ContractService","constructor","provider","signer","contract","initialize","Contract","contracts","shardFlip","isInitialized","flipCoin","amount","choice","success","error","betAmount","parseEther","choiceBool","minBet","MIN_BET","Error","formatEther","maxBet","MAX_BET","contractBalance","getContractBalance","payoutMultiplier","PAYOUT_MULTIPLIER","potentialPayout","isPaused","paused","gasLimit","gasEstimate","estimateGas","value","gasError","console","warn","gasPrice","getFeeData","tx","receipt","wait","status","txHash","hash","_error$message","_error$message2","_error$message3","_error$message4","_error$message5","errorMessage","code","message","includes","getPlayerStats","address","stats","totalGames","Number","totalWins","totalWagered","totalWon","winRate","netProfit","parseFloat","toString","getRecentGames","limit","games","slice","map","game","index","id","player","timestamp","result","won","payout","getGameStats","totalVolume","totalPayout","activeUsers","getLeaderboard","players","wins","wagered","getTopPlayers","waitForTransaction","parseGameEvents","fromBlock","filter","filters","GamePlayed","events","queryFilter","event","args","transactionHash","setupEventListeners","onGamePlayed","handleGamePlayed","on","off","disconnect","removeAllListeners","contractService"],"sources":["/Users/nickkz/Desktop/Shard-Flip/src/services/contractService.ts"],"sourcesContent":["import { ethers } from 'ethers';\nimport { GameResult, PlayerStats, GameStats, LeaderboardEntry, CoinSide } from '../types';\nimport { CONTRACT_ABI, SHARDEUM_UNSTABLE } from '../utils/constants';\nimport toast from 'react-hot-toast';\n\nexport class ContractService {\n  private contract: ethers.Contract | null = null;\n  private provider: ethers.BrowserProvider | null = null;\n  private signer: ethers.JsonRpcSigner | null = null;\n\n  constructor(provider?: ethers.BrowserProvider, signer?: ethers.JsonRpcSigner) {\n    if (provider && signer) {\n      this.initialize(provider, signer);\n    }\n  }\n\n  initialize(provider: ethers.BrowserProvider, signer: ethers.JsonRpcSigner) {\n    this.provider = provider;\n    this.signer = signer;\n    this.contract = new ethers.Contract(\n      SHARDEUM_UNSTABLE.contracts.shardFlip,\n      CONTRACT_ABI,\n      signer\n    );\n  }\n\n  isInitialized(): boolean {\n    return this.contract !== null && this.signer !== null && this.provider !== null;\n  }\n\n  async flipCoin(amount: string, choice: CoinSide): Promise<{ success: boolean; txHash?: string; error?: string }> {\n    if (!this.isInitialized()) {\n      return { success: false, error: 'Contract not initialized' };\n    }\n\n    try {\n      const betAmount = ethers.parseEther(amount);\n      const choiceBool = choice === 'heads'; // true for heads, false for tails\n\n      // Check minimum bet amount\n      const minBet = await this.contract!.MIN_BET();\n      if (betAmount < minBet) {\n        throw new Error(`Minimum bet is ${ethers.formatEther(minBet)} SHM`);\n      }\n\n      // Check maximum bet amount\n      const maxBet = await this.contract!.MAX_BET();\n      if (betAmount > maxBet) {\n        throw new Error(`Maximum bet is ${ethers.formatEther(maxBet)} SHM`);\n      }\n\n      // Check contract balance for potential payout\n      const contractBalance = await this.contract!.getContractBalance();\n      const payoutMultiplier = await this.contract!.PAYOUT_MULTIPLIER();\n      const potentialPayout = betAmount * payoutMultiplier / 100n;\n      \n      if (contractBalance < potentialPayout) {\n        throw new Error('Contract has insufficient balance for this bet');\n      }\n\n      // Check if contract is paused\n      const isPaused = await this.contract!.paused();\n      if (isPaused) {\n        throw new Error('Contract is currently paused');\n      }\n\n      let gasLimit;\n      try {\n        // Estimate gas with a more conservative approach\n        const gasEstimate = await this.contract!.flipCoin.estimateGas(choiceBool, {\n          value: betAmount\n        });\n        gasLimit = gasEstimate * 150n / 100n; // 50% buffer\n      } catch (gasError) {\n        console.warn('Gas estimation failed, using fallback:', gasError);\n        gasLimit = 500000n; // Fallback gas limit\n      }\n\n      // Get current gas price\n      const gasPrice = await this.provider!.getFeeData();\n      \n      const tx = await this.contract!.flipCoin(choiceBool, {\n        value: betAmount,\n        gasLimit: gasLimit,\n        gasPrice: gasPrice.gasPrice\n      });\n\n      toast.success('Transaction sent! Waiting for confirmation...');\n      \n      const receipt = await tx.wait();\n      \n      if (receipt && receipt.status === 1) {\n        toast.success('Coin flip completed!');\n        return { success: true, txHash: tx.hash };\n      } else {\n        throw new Error('Transaction failed');\n      }\n\n    } catch (error: any) {\n      console.error('Error flipping coin:', error);\n      \n      let errorMessage = 'Failed to flip coin';\n      \n      if (error.code === 'ACTION_REJECTED') {\n        errorMessage = 'Transaction rejected by user';\n      } else if (error.code === 'INSUFFICIENT_FUNDS') {\n        errorMessage = 'Insufficient funds for bet + gas';\n      } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        errorMessage = 'Cannot estimate gas - contract may be paused or have insufficient balance';\n      } else if (error.message?.includes('insufficient funds')) {\n        errorMessage = 'Insufficient SHM balance';\n      } else if (error.message?.includes('Minimum bet')) {\n        errorMessage = error.message;\n      } else if (error.message?.includes('Maximum bet')) {\n        errorMessage = error.message;\n      } else if (error.message?.includes('insufficient balance')) {\n        errorMessage = error.message;\n      } else if (error.message?.includes('paused')) {\n        errorMessage = error.message;\n      } else if (error.code === -32603) {\n        errorMessage = 'Network error - please try again';\n      }\n\n      toast.error(errorMessage);\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  async getPlayerStats(address: string): Promise<PlayerStats | null> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n\n    try {\n      const stats = await this.contract!.getPlayerStats(address);\n      \n      // The contract returns individual values\n      const totalGames = Number(stats[0]);\n      const totalWins = Number(stats[1]);\n      const totalWagered = ethers.formatEther(stats[2]);\n      const totalWon = ethers.formatEther(stats[3]);\n\n      return {\n        totalGames,\n        totalWins,\n        winRate: totalGames > 0 ? (totalWins / totalGames) * 100 : 0,\n        totalWagered,\n        totalWon,\n        netProfit: (parseFloat(totalWon) - parseFloat(totalWagered)).toString()\n      };\n\n    } catch (error) {\n      console.error('Error fetching player stats:', error);\n      // Return default stats instead of null to prevent UI issues\n      return {\n        totalGames: 0,\n        totalWins: 0,\n        winRate: 0,\n        totalWagered: '0',\n        totalWon: '0',\n        netProfit: '0'\n      };\n    }\n  }\n\n  async getRecentGames(limit: number = 50): Promise<GameResult[]> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n\n    try {\n      const games = await this.contract!.getRecentGames();\n      \n      return games.slice(0, limit).map((game: any, index: number) => ({\n        id: `${game.player}-${game.timestamp}-${index}`,\n        player: game.player,\n        betAmount: ethers.formatEther(game.betAmount),\n        choice: game.choice ? 'heads' : 'tails',\n        result: game.result ? 'heads' : 'tails',\n        won: game.won,\n        payout: ethers.formatEther(game.payout),\n        timestamp: Number(game.timestamp),\n        txHash: '' // This would need to be tracked separately or obtained from events\n      }));\n\n    } catch (error) {\n      console.error('Error fetching recent games:', error);\n      return [];\n    }\n  }\n\n  async getGameStats(): Promise<GameStats | null> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n\n    try {\n      const stats = await this.contract!.getGameStats();\n      \n      // The new contract returns individual values, not a struct\n      return {\n        totalGames: Number(stats[0]),\n        totalVolume: ethers.formatEther(stats[1]),\n        totalPayout: ethers.formatEther(stats[2]),\n        activeUsers: Number(stats[3])\n      };\n\n    } catch (error) {\n      console.error('Error fetching game stats:', error);\n      return null;\n    }\n  }\n\n  async getLeaderboard(limit: number = 10): Promise<LeaderboardEntry[]> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n\n    try {\n      const [players, wins, wagered] = await this.contract!.getTopPlayers(limit);\n      \n      return players.map((player: string, index: number) => ({\n        address: player,\n        wins: Number(wins[index]),\n        totalWagered: ethers.formatEther(wagered[index]),\n        netProfit: '0', // Would need additional calculation\n        winRate: 0 // Would need total games to calculate\n      }));\n    } catch (error) {\n      console.error('Error fetching leaderboard:', error);\n      return [];\n    }\n  }\n\n  async waitForTransaction(txHash: string): Promise<boolean> {\n    if (!this.provider) return false;\n\n    try {\n      const receipt = await this.provider.waitForTransaction(txHash, 1, 30000); // 30 second timeout\n      return receipt ? receipt.status === 1 : false;\n    } catch (error) {\n      console.error('Error waiting for transaction:', error);\n      return false;\n    }\n  }\n\n  // Utility method to parse game events (for real-time updates)\n  async parseGameEvents(fromBlock: number = 0): Promise<GameResult[]> {\n    if (!this.contract || !this.provider) return [];\n\n    try {\n      // This would parse GamePlayed events from the contract\n      // Implementation depends on the actual contract events\n      const filter = this.contract.filters.GamePlayed();\n      const events = await this.contract.queryFilter(filter, fromBlock);\n      \n      return events.map((event: any) => {\n        const args = event.args;\n        return {\n          id: `${args.player}-${args.timestamp}`,\n          player: args.player,\n          betAmount: ethers.formatEther(args.betAmount),\n          choice: args.choice ? 'heads' : 'tails',\n          result: args.result ? 'heads' : 'tails',\n          won: args.won,\n          payout: ethers.formatEther(args.payout),\n          timestamp: Number(args.timestamp),\n          txHash: event.transactionHash\n        };\n      });\n\n    } catch (error) {\n      console.error('Error parsing game events:', error);\n      return [];\n    }\n  }\n\n  // Listen for real-time game events\n  setupEventListeners(onGamePlayed?: (game: GameResult) => void): () => void {\n    if (!this.contract) {\n      return () => {};\n    }\n\n    const handleGamePlayed = (player: string, betAmount: bigint, choice: boolean, result: boolean, won: boolean, payout: bigint, timestamp: bigint) => {\n      const game: GameResult = {\n        id: `${player}-${timestamp}`,\n        player,\n        betAmount: ethers.formatEther(betAmount),\n        choice: choice ? 'heads' : 'tails',\n        result: result ? 'heads' : 'tails',\n        won,\n        payout: ethers.formatEther(payout),\n        timestamp: Number(timestamp),\n        txHash: '' // Would be available in the event context\n      };\n\n      if (onGamePlayed) {\n        onGamePlayed(game);\n      }\n    };\n\n    try {\n      this.contract.on('GamePlayed', handleGamePlayed);\n      \n      return () => {\n        if (this.contract) {\n          this.contract.off('GamePlayed', handleGamePlayed);\n        }\n      };\n    } catch (error) {\n      console.error('Error setting up event listeners:', error);\n      return () => {};\n    }\n  }\n\n  disconnect() {\n    if (this.contract) {\n      this.contract.removeAllListeners();\n    }\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n  }\n}\n\n// Singleton instance\nexport const contractService = new ContractService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}