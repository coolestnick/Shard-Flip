{"ast":null,"code":"import { ethers } from 'ethers';\nimport { CONTRACT_ABI, SHARDEUM_UNSTABLE } from '../utils/constants';\nimport toast from 'react-hot-toast';\nexport class ContractService {\n  constructor(provider, signer) {\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n    if (provider && signer) {\n      this.initialize(provider, signer);\n    }\n  }\n  initialize(provider, signer) {\n    this.provider = provider;\n    this.signer = signer;\n    this.contract = new ethers.Contract(SHARDEUM_UNSTABLE.contracts.shardFlip, CONTRACT_ABI, signer);\n  }\n  isInitialized() {\n    return this.contract !== null && this.signer !== null && this.provider !== null;\n  }\n  async flipCoin(amount, choice) {\n    if (!this.isInitialized()) {\n      return {\n        success: false,\n        error: 'Contract not initialized'\n      };\n    }\n    try {\n      const betAmount = ethers.parseEther(amount);\n      const choiceBool = choice === 'heads'; // true for heads, false for tails\n\n      // Estimate gas\n      const gasEstimate = await this.contract.flipCoin.estimateGas(choiceBool, {\n        value: betAmount\n      });\n\n      // Add 20% buffer to gas estimate\n      const gasLimit = gasEstimate * 120n / 100n;\n      const tx = await this.contract.flipCoin(choiceBool, {\n        value: betAmount,\n        gasLimit: gasLimit\n      });\n      toast.success('Transaction sent! Waiting for confirmation...');\n      const receipt = await tx.wait();\n      if (receipt.status === 1) {\n        toast.success('Coin flip completed!');\n        return {\n          success: true,\n          txHash: tx.hash\n        };\n      } else {\n        throw new Error('Transaction failed');\n      }\n    } catch (error) {\n      var _error$message;\n      console.error('Error flipping coin:', error);\n      let errorMessage = 'Failed to flip coin';\n      if (error.code === 'ACTION_REJECTED') {\n        errorMessage = 'Transaction rejected by user';\n      } else if (error.code === 'INSUFFICIENT_FUNDS') {\n        errorMessage = 'Insufficient funds for bet + gas';\n      } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        errorMessage = 'Cannot estimate gas - check bet amount and contract';\n      } else if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('insufficient funds')) {\n        errorMessage = 'Insufficient SHM balance';\n      }\n      toast.error(errorMessage);\n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n  async getPlayerStats(address) {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n    try {\n      const stats = await this.contract.getPlayerStats(address);\n\n      // The new contract returns individual values, not a struct\n      const totalGames = Number(stats[0]);\n      const totalWins = Number(stats[1]);\n      const totalWagered = ethers.formatEther(stats[2]);\n      const totalWon = ethers.formatEther(stats[3]);\n      return {\n        totalGames,\n        totalWins,\n        winRate: totalGames > 0 ? totalWins / totalGames * 100 : 0,\n        totalWagered,\n        totalWon,\n        netProfit: (parseFloat(totalWon) - parseFloat(totalWagered)).toString()\n      };\n    } catch (error) {\n      console.error('Error fetching player stats:', error);\n      return null;\n    }\n  }\n  async getRecentGames(limit = 50) {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n    try {\n      const games = await this.contract.getRecentGames();\n      return games.slice(0, limit).map((game, index) => ({\n        id: `${game.player}-${game.timestamp}-${index}`,\n        player: game.player,\n        betAmount: ethers.formatEther(game.betAmount),\n        choice: game.choice ? 'heads' : 'tails',\n        result: game.result ? 'heads' : 'tails',\n        won: game.won,\n        payout: ethers.formatEther(game.payout),\n        timestamp: Number(game.timestamp),\n        txHash: '' // This would need to be tracked separately or obtained from events\n      }));\n    } catch (error) {\n      console.error('Error fetching recent games:', error);\n      return [];\n    }\n  }\n  async getGameStats() {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n    try {\n      const stats = await this.contract.getGameStats();\n      return {\n        totalGames: Number(stats.totalGames),\n        totalVolume: ethers.formatEther(stats.totalVolume),\n        totalPayout: ethers.formatEther(stats.totalPayout),\n        activeUsers: Number(stats.activeUsers)\n      };\n    } catch (error) {\n      console.error('Error fetching game stats:', error);\n      return null;\n    }\n  }\n  async getLeaderboard(limit = 10) {\n    // Note: This would typically require additional contract methods or indexing\n    // For now, we'll return mock data or implement a simpler version\n\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n    try {\n      // This is a simplified implementation\n      // In a real scenario, you'd need events or additional contract methods\n      return [];\n    } catch (error) {\n      console.error('Error fetching leaderboard:', error);\n      return [];\n    }\n  }\n  async waitForTransaction(txHash) {\n    if (!this.provider) return false;\n    try {\n      const receipt = await this.provider.waitForTransaction(txHash, 1, 30000); // 30 second timeout\n      return receipt ? receipt.status === 1 : false;\n    } catch (error) {\n      console.error('Error waiting for transaction:', error);\n      return false;\n    }\n  }\n\n  // Utility method to parse game events (for real-time updates)\n  async parseGameEvents(fromBlock = 0) {\n    if (!this.contract || !this.provider) return [];\n    try {\n      // This would parse GamePlayed events from the contract\n      // Implementation depends on the actual contract events\n      const filter = this.contract.filters.GamePlayed();\n      const events = await this.contract.queryFilter(filter, fromBlock);\n      return events.map(event => {\n        const args = event.args;\n        return {\n          id: `${args.player}-${args.timestamp}`,\n          player: args.player,\n          betAmount: ethers.formatEther(args.betAmount),\n          choice: args.choice ? 'heads' : 'tails',\n          result: args.result ? 'heads' : 'tails',\n          won: args.won,\n          payout: ethers.formatEther(args.payout),\n          timestamp: Number(args.timestamp),\n          txHash: event.transactionHash\n        };\n      });\n    } catch (error) {\n      console.error('Error parsing game events:', error);\n      return [];\n    }\n  }\n\n  // Listen for real-time game events\n  setupEventListeners(onGamePlayed) {\n    if (!this.contract) {\n      return () => {};\n    }\n    const handleGamePlayed = (player, betAmount, choice, result, won, payout, timestamp) => {\n      const game = {\n        id: `${player}-${timestamp}`,\n        player,\n        betAmount: ethers.formatEther(betAmount),\n        choice: choice ? 'heads' : 'tails',\n        result: result ? 'heads' : 'tails',\n        won,\n        payout: ethers.formatEther(payout),\n        timestamp: Number(timestamp),\n        txHash: '' // Would be available in the event context\n      };\n      if (onGamePlayed) {\n        onGamePlayed(game);\n      }\n    };\n    try {\n      this.contract.on('GamePlayed', handleGamePlayed);\n      return () => {\n        if (this.contract) {\n          this.contract.off('GamePlayed', handleGamePlayed);\n        }\n      };\n    } catch (error) {\n      console.error('Error setting up event listeners:', error);\n      return () => {};\n    }\n  }\n  disconnect() {\n    if (this.contract) {\n      this.contract.removeAllListeners();\n    }\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n  }\n}\n\n// Singleton instance\nexport const contractService = new ContractService();","map":{"version":3,"names":["ethers","CONTRACT_ABI","SHARDEUM_UNSTABLE","toast","ContractService","constructor","provider","signer","contract","initialize","Contract","contracts","shardFlip","isInitialized","flipCoin","amount","choice","success","error","betAmount","parseEther","choiceBool","gasEstimate","estimateGas","value","gasLimit","tx","receipt","wait","status","txHash","hash","Error","_error$message","console","errorMessage","code","message","includes","getPlayerStats","address","stats","totalGames","Number","totalWins","totalWagered","formatEther","totalWon","winRate","netProfit","parseFloat","toString","getRecentGames","limit","games","slice","map","game","index","id","player","timestamp","result","won","payout","getGameStats","totalVolume","totalPayout","activeUsers","getLeaderboard","waitForTransaction","parseGameEvents","fromBlock","filter","filters","GamePlayed","events","queryFilter","event","args","transactionHash","setupEventListeners","onGamePlayed","handleGamePlayed","on","off","disconnect","removeAllListeners","contractService"],"sources":["/Users/nickkz/Desktop/Shard-Flip/src/services/contractService.ts"],"sourcesContent":["import { ethers } from 'ethers';\nimport { GameResult, PlayerStats, GameStats, LeaderboardEntry, CoinSide } from '../types';\nimport { CONTRACT_ABI, SHARDEUM_UNSTABLE } from '../utils/constants';\nimport toast from 'react-hot-toast';\n\nexport class ContractService {\n  private contract: ethers.Contract | null = null;\n  private provider: ethers.BrowserProvider | null = null;\n  private signer: ethers.JsonRpcSigner | null = null;\n\n  constructor(provider?: ethers.BrowserProvider, signer?: ethers.JsonRpcSigner) {\n    if (provider && signer) {\n      this.initialize(provider, signer);\n    }\n  }\n\n  initialize(provider: ethers.BrowserProvider, signer: ethers.JsonRpcSigner) {\n    this.provider = provider;\n    this.signer = signer;\n    this.contract = new ethers.Contract(\n      SHARDEUM_UNSTABLE.contracts.shardFlip,\n      CONTRACT_ABI,\n      signer\n    );\n  }\n\n  isInitialized(): boolean {\n    return this.contract !== null && this.signer !== null && this.provider !== null;\n  }\n\n  async flipCoin(amount: string, choice: CoinSide): Promise<{ success: boolean; txHash?: string; error?: string }> {\n    if (!this.isInitialized()) {\n      return { success: false, error: 'Contract not initialized' };\n    }\n\n    try {\n      const betAmount = ethers.parseEther(amount);\n      const choiceBool = choice === 'heads'; // true for heads, false for tails\n\n      // Estimate gas\n      const gasEstimate = await this.contract!.flipCoin.estimateGas(choiceBool, {\n        value: betAmount\n      });\n\n      // Add 20% buffer to gas estimate\n      const gasLimit = gasEstimate * 120n / 100n;\n\n      const tx = await this.contract!.flipCoin(choiceBool, {\n        value: betAmount,\n        gasLimit: gasLimit\n      });\n\n      toast.success('Transaction sent! Waiting for confirmation...');\n      \n      const receipt = await tx.wait();\n      \n      if (receipt.status === 1) {\n        toast.success('Coin flip completed!');\n        return { success: true, txHash: tx.hash };\n      } else {\n        throw new Error('Transaction failed');\n      }\n\n    } catch (error: any) {\n      console.error('Error flipping coin:', error);\n      \n      let errorMessage = 'Failed to flip coin';\n      \n      if (error.code === 'ACTION_REJECTED') {\n        errorMessage = 'Transaction rejected by user';\n      } else if (error.code === 'INSUFFICIENT_FUNDS') {\n        errorMessage = 'Insufficient funds for bet + gas';\n      } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        errorMessage = 'Cannot estimate gas - check bet amount and contract';\n      } else if (error.message?.includes('insufficient funds')) {\n        errorMessage = 'Insufficient SHM balance';\n      }\n\n      toast.error(errorMessage);\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  async getPlayerStats(address: string): Promise<PlayerStats | null> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n\n    try {\n      const stats = await this.contract!.getPlayerStats(address);\n      \n      // The new contract returns individual values, not a struct\n      const totalGames = Number(stats[0]);\n      const totalWins = Number(stats[1]);\n      const totalWagered = ethers.formatEther(stats[2]);\n      const totalWon = ethers.formatEther(stats[3]);\n\n      return {\n        totalGames,\n        totalWins,\n        winRate: totalGames > 0 ? (totalWins / totalGames) * 100 : 0,\n        totalWagered,\n        totalWon,\n        netProfit: (parseFloat(totalWon) - parseFloat(totalWagered)).toString()\n      };\n\n    } catch (error) {\n      console.error('Error fetching player stats:', error);\n      return null;\n    }\n  }\n\n  async getRecentGames(limit: number = 50): Promise<GameResult[]> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n\n    try {\n      const games = await this.contract!.getRecentGames();\n      \n      return games.slice(0, limit).map((game: any, index: number) => ({\n        id: `${game.player}-${game.timestamp}-${index}`,\n        player: game.player,\n        betAmount: ethers.formatEther(game.betAmount),\n        choice: game.choice ? 'heads' : 'tails',\n        result: game.result ? 'heads' : 'tails',\n        won: game.won,\n        payout: ethers.formatEther(game.payout),\n        timestamp: Number(game.timestamp),\n        txHash: '' // This would need to be tracked separately or obtained from events\n      }));\n\n    } catch (error) {\n      console.error('Error fetching recent games:', error);\n      return [];\n    }\n  }\n\n  async getGameStats(): Promise<GameStats | null> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n\n    try {\n      const stats = await this.contract!.getGameStats();\n      \n      return {\n        totalGames: Number(stats.totalGames),\n        totalVolume: ethers.formatEther(stats.totalVolume),\n        totalPayout: ethers.formatEther(stats.totalPayout),\n        activeUsers: Number(stats.activeUsers)\n      };\n\n    } catch (error) {\n      console.error('Error fetching game stats:', error);\n      return null;\n    }\n  }\n\n  async getLeaderboard(limit: number = 10): Promise<LeaderboardEntry[]> {\n    // Note: This would typically require additional contract methods or indexing\n    // For now, we'll return mock data or implement a simpler version\n    \n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n\n    try {\n      // This is a simplified implementation\n      // In a real scenario, you'd need events or additional contract methods\n      return [];\n    } catch (error) {\n      console.error('Error fetching leaderboard:', error);\n      return [];\n    }\n  }\n\n  async waitForTransaction(txHash: string): Promise<boolean> {\n    if (!this.provider) return false;\n\n    try {\n      const receipt = await this.provider.waitForTransaction(txHash, 1, 30000); // 30 second timeout\n      return receipt ? receipt.status === 1 : false;\n    } catch (error) {\n      console.error('Error waiting for transaction:', error);\n      return false;\n    }\n  }\n\n  // Utility method to parse game events (for real-time updates)\n  async parseGameEvents(fromBlock: number = 0): Promise<GameResult[]> {\n    if (!this.contract || !this.provider) return [];\n\n    try {\n      // This would parse GamePlayed events from the contract\n      // Implementation depends on the actual contract events\n      const filter = this.contract.filters.GamePlayed();\n      const events = await this.contract.queryFilter(filter, fromBlock);\n      \n      return events.map((event: any) => {\n        const args = event.args;\n        return {\n          id: `${args.player}-${args.timestamp}`,\n          player: args.player,\n          betAmount: ethers.formatEther(args.betAmount),\n          choice: args.choice ? 'heads' : 'tails',\n          result: args.result ? 'heads' : 'tails',\n          won: args.won,\n          payout: ethers.formatEther(args.payout),\n          timestamp: Number(args.timestamp),\n          txHash: event.transactionHash\n        };\n      });\n\n    } catch (error) {\n      console.error('Error parsing game events:', error);\n      return [];\n    }\n  }\n\n  // Listen for real-time game events\n  setupEventListeners(onGamePlayed?: (game: GameResult) => void): () => void {\n    if (!this.contract) {\n      return () => {};\n    }\n\n    const handleGamePlayed = (player: string, betAmount: bigint, choice: boolean, result: boolean, won: boolean, payout: bigint, timestamp: bigint) => {\n      const game: GameResult = {\n        id: `${player}-${timestamp}`,\n        player,\n        betAmount: ethers.formatEther(betAmount),\n        choice: choice ? 'heads' : 'tails',\n        result: result ? 'heads' : 'tails',\n        won,\n        payout: ethers.formatEther(payout),\n        timestamp: Number(timestamp),\n        txHash: '' // Would be available in the event context\n      };\n\n      if (onGamePlayed) {\n        onGamePlayed(game);\n      }\n    };\n\n    try {\n      this.contract.on('GamePlayed', handleGamePlayed);\n      \n      return () => {\n        if (this.contract) {\n          this.contract.off('GamePlayed', handleGamePlayed);\n        }\n      };\n    } catch (error) {\n      console.error('Error setting up event listeners:', error);\n      return () => {};\n    }\n  }\n\n  disconnect() {\n    if (this.contract) {\n      this.contract.removeAllListeners();\n    }\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n  }\n}\n\n// Singleton instance\nexport const contractService = new ContractService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}