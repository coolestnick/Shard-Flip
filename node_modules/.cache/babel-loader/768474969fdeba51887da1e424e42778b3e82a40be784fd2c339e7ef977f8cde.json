{"ast":null,"code":"import { ethers } from 'ethers';\nimport { CONTRACT_ABI, SHARDEUM_UNSTABLE } from '../utils/constants';\nimport { apiService } from './apiService';\nimport toast from 'react-hot-toast';\nexport class ContractService {\n  constructor(provider, signer) {\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n    if (provider && signer) {\n      this.initialize(provider, signer);\n    }\n  }\n  initialize(provider, signer) {\n    this.provider = provider;\n    this.signer = signer;\n    this.contract = new ethers.Contract(SHARDEUM_UNSTABLE.contracts.shardFlip, CONTRACT_ABI, signer);\n  }\n  isInitialized() {\n    return this.contract !== null && this.signer !== null && this.provider !== null;\n  }\n  async flipCoin(amount, choice) {\n    if (!this.isInitialized()) {\n      return {\n        success: false,\n        error: 'Contract not initialized'\n      };\n    }\n    try {\n      const betAmount = ethers.parseEther(amount);\n      const choiceBool = choice === 'heads'; // true for heads, false for tails\n\n      // Store bet info for fallback update\n      const betInfo = {\n        amount: parseFloat(amount),\n        choice: choice,\n        player: this.signer ? await this.signer.getAddress() : null\n      };\n\n      // Check minimum bet amount\n      const minBet = await this.contract.MIN_BET();\n      if (betAmount < minBet) {\n        throw new Error(`Minimum bet is ${ethers.formatEther(minBet)} SHM`);\n      }\n\n      // Check maximum bet amount\n      const maxBet = await this.contract.MAX_BET();\n      if (betAmount > maxBet) {\n        throw new Error(`Maximum bet is ${ethers.formatEther(maxBet)} SHM`);\n      }\n\n      // Check contract balance for potential payout\n      const contractBalance = await this.contract.getContractBalance();\n      const payoutMultiplier = await this.contract.PAYOUT_MULTIPLIER();\n      const potentialPayout = betAmount * payoutMultiplier / BigInt(100);\n      if (contractBalance < potentialPayout) {\n        throw new Error('Contract has insufficient balance for this bet');\n      }\n\n      // Check if contract is paused\n      const isPaused = await this.contract.paused();\n      if (isPaused) {\n        throw new Error('Contract is currently paused');\n      }\n      let gasLimit;\n      try {\n        // Estimate gas with a more conservative approach\n        const gasEstimate = await this.contract.flipCoin.estimateGas(choiceBool, {\n          value: betAmount\n        });\n        gasLimit = gasEstimate * BigInt(150) / BigInt(100); // 50% buffer\n      } catch (gasError) {\n        console.warn('Gas estimation failed, using fallback:', gasError);\n        gasLimit = BigInt(500000); // Fallback gas limit\n      }\n\n      // Get current gas price\n      const gasPrice = await this.provider.getFeeData();\n      const tx = await this.contract.flipCoin(choiceBool, {\n        value: betAmount,\n        gasLimit: gasLimit,\n        gasPrice: gasPrice.gasPrice\n      });\n      toast.success('Transaction sent! Waiting for confirmation...');\n      const receipt = await tx.wait();\n      if (receipt && receipt.status === 1) {\n        toast.success('Coin flip completed!');\n\n        // Get the game result from transaction receipt\n        const gameResult = await this.parseGameResultFromReceipt(receipt);\n\n        // Always attempt backend update after successful transaction\n        if (this.signer) {\n          const playerAddress = await this.signer.getAddress();\n          console.log('🎮 Updating backend for successful game by:', playerAddress);\n          console.log('💰 Bet amount:', betInfo.amount, 'SHM');\n          try {\n            // First, get the actual game result from the blockchain\n            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s for blockchain to update\n\n            if (gameResult) {\n              console.log('📊 Parsed game result:', {\n                won: gameResult.won,\n                betAmount: ethers.formatEther(gameResult.betAmount),\n                payout: ethers.formatEther(gameResult.payout)\n              });\n              const result = await apiService.updateGameResult(playerAddress, gameResult.won ? 'win' : 'loss', parseFloat(ethers.formatEther(gameResult.betAmount)), gameResult.won ? parseFloat(ethers.formatEther(gameResult.payout)) : 0);\n              console.log('✅ Backend update result:', result);\n            } else {\n              console.log('⚠️ Could not parse game result from receipt, checking contract directly...');\n\n              // Fallback: Check contract for recent games\n              try {\n                const recentGames = await this.getRecentGames(5);\n                const playerGame = recentGames.find(game => game.player.toLowerCase() === playerAddress.toLowerCase() && Math.abs(parseFloat(game.betAmount) - betInfo.amount) < 0.001);\n                if (playerGame) {\n                  console.log('🎯 Found matching game in contract:', playerGame);\n                  const result = await apiService.updateGameResult(playerAddress, playerGame.won ? 'win' : 'loss', parseFloat(playerGame.betAmount), parseFloat(playerGame.payout));\n                  console.log('✅ Backend updated from contract data:', result);\n                } else {\n                  console.log('🔍 No matching game found, using bet amount as fallback');\n                  // Last resort: assume loss if we can't determine result\n                  const result = await apiService.updateGameResult(playerAddress, 'loss',\n                  // Conservative assumption\n                  betInfo.amount, 0);\n                  console.log('✅ Backend updated with fallback (assumed loss):', result);\n                }\n              } catch (contractError) {\n                console.error('Failed to get game from contract:', contractError);\n              }\n            }\n          } catch (backendError) {\n            console.error('❌ Failed to update backend:', backendError);\n            console.log('🔧 Backend error details:', {\n              url: process.env.REACT_APP_API_URL,\n              hasApiKey: !!process.env.REACT_APP_API_SECRET_KEY\n            });\n          }\n        }\n        return {\n          success: true,\n          txHash: tx.hash\n        };\n      } else {\n        throw new Error('Transaction failed');\n      }\n    } catch (error) {\n      var _error$message, _error$message2, _error$message3, _error$message4, _error$message5;\n      console.error('Error flipping coin:', error);\n      let errorMessage = 'Failed to flip coin';\n      if (error.code === 'ACTION_REJECTED') {\n        errorMessage = 'Transaction rejected by user';\n      } else if (error.code === 'INSUFFICIENT_FUNDS') {\n        errorMessage = 'Insufficient funds for bet + gas';\n      } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        errorMessage = 'Cannot estimate gas - contract may be paused or have insufficient balance';\n      } else if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('insufficient funds')) {\n        errorMessage = 'Insufficient SHM balance';\n      } else if ((_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('Minimum bet')) {\n        errorMessage = error.message;\n      } else if ((_error$message3 = error.message) !== null && _error$message3 !== void 0 && _error$message3.includes('Maximum bet')) {\n        errorMessage = error.message;\n      } else if ((_error$message4 = error.message) !== null && _error$message4 !== void 0 && _error$message4.includes('insufficient balance')) {\n        errorMessage = error.message;\n      } else if ((_error$message5 = error.message) !== null && _error$message5 !== void 0 && _error$message5.includes('paused')) {\n        errorMessage = error.message;\n      } else if (error.code === -32603) {\n        errorMessage = 'Network error - please try again';\n      }\n      toast.error(errorMessage);\n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n  async getPlayerStats(address) {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n    try {\n      const stats = await this.contract.getPlayerStats(address);\n\n      // The contract returns individual values\n      const totalGames = Number(stats[0]);\n      const totalWins = Number(stats[1]);\n      const totalWagered = ethers.formatEther(stats[2]);\n      const totalWon = ethers.formatEther(stats[3]);\n      return {\n        totalGames,\n        totalWins,\n        winRate: totalGames > 0 ? totalWins / totalGames * 100 : 0,\n        totalWagered,\n        totalWon,\n        netProfit: (parseFloat(totalWon) - parseFloat(totalWagered)).toString()\n      };\n    } catch (error) {\n      console.error('Error fetching player stats:', error);\n      // Return default stats instead of null to prevent UI issues\n      return {\n        totalGames: 0,\n        totalWins: 0,\n        winRate: 0,\n        totalWagered: '0',\n        totalWon: '0',\n        netProfit: '0'\n      };\n    }\n  }\n  async getRecentGames(limit = 50) {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n    try {\n      const games = await this.contract.getRecentGames();\n      return games.slice(0, limit).map((game, index) => ({\n        id: `${game.player}-${game.timestamp}-${index}`,\n        player: game.player,\n        betAmount: ethers.formatEther(game.betAmount),\n        choice: game.choice ? 'heads' : 'tails',\n        result: game.result ? 'heads' : 'tails',\n        won: game.won,\n        payout: ethers.formatEther(game.payout),\n        timestamp: Number(game.timestamp),\n        txHash: '' // This would need to be tracked separately or obtained from events\n      }));\n    } catch (error) {\n      console.error('Error fetching recent games:', error);\n      return [];\n    }\n  }\n  async getGameStats() {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n    try {\n      const stats = await this.contract.getGameStats();\n\n      // The new contract returns individual values, not a struct\n      return {\n        totalGames: Number(stats[0]),\n        totalVolume: ethers.formatEther(stats[1]),\n        totalPayout: ethers.formatEther(stats[2]),\n        activeUsers: Number(stats[3])\n      };\n    } catch (error) {\n      console.error('Error fetching game stats:', error);\n      return null;\n    }\n  }\n  async getLeaderboard(limit = 10) {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n    try {\n      const [players, wins, wagered] = await this.contract.getTopPlayers(limit);\n      return players.map((player, index) => ({\n        address: player,\n        wins: Number(wins[index]),\n        totalWagered: ethers.formatEther(wagered[index]),\n        netProfit: '0',\n        // Would need additional calculation\n        winRate: 0 // Would need total games to calculate\n      }));\n    } catch (error) {\n      console.error('Error fetching leaderboard:', error);\n      return [];\n    }\n  }\n  async waitForTransaction(txHash) {\n    if (!this.provider) {\n      console.error('Provider not available for transaction waiting');\n      return false;\n    }\n    try {\n      console.log('⏳ Waiting for transaction confirmation:', txHash);\n\n      // Wait for 1 confirmation with 60 second timeout\n      const receipt = await this.provider.waitForTransaction(txHash, 1, 60000);\n      if (receipt) {\n        const success = receipt.status === 1;\n        console.log(success ? '✅ Transaction confirmed successfully' : '❌ Transaction failed');\n        return success;\n      } else {\n        console.warn('⚠️ Transaction receipt not received within timeout');\n        return false;\n      }\n    } catch (error) {\n      var _error$message6;\n      console.error('❌ Error waiting for transaction:', error);\n\n      // If it's a timeout error, don't treat it as complete failure\n      if (error.code === 'TIMEOUT' || (_error$message6 = error.message) !== null && _error$message6 !== void 0 && _error$message6.includes('timeout')) {\n        console.warn('⏰ Transaction confirmation timed out, but may still succeed');\n      }\n      return false;\n    }\n  }\n\n  // Utility method to parse game events (for real-time updates)\n  async parseGameEvents(fromBlock = 0) {\n    if (!this.contract || !this.provider) return [];\n    try {\n      // This would parse GamePlayed events from the contract\n      // Implementation depends on the actual contract events\n      const filter = this.contract.filters.GamePlayed();\n      const events = await this.contract.queryFilter(filter, fromBlock);\n      return events.map(event => {\n        const args = event.args;\n        return {\n          id: `${args.player}-${args.timestamp}`,\n          player: args.player,\n          betAmount: ethers.formatEther(args.betAmount),\n          choice: args.choice ? 'heads' : 'tails',\n          result: args.result ? 'heads' : 'tails',\n          won: args.won,\n          payout: ethers.formatEther(args.payout),\n          timestamp: Number(args.timestamp),\n          txHash: event.transactionHash\n        };\n      });\n    } catch (error) {\n      console.error('Error parsing game events:', error);\n      return [];\n    }\n  }\n\n  // Listen for real-time game events\n  setupEventListeners(onGamePlayed) {\n    if (!this.contract) {\n      return () => {};\n    }\n    const handleGamePlayed = (player, betAmount, choice, result, won, payout, timestamp) => {\n      const game = {\n        id: `${player}-${timestamp}`,\n        player,\n        betAmount: ethers.formatEther(betAmount),\n        choice: choice ? 'heads' : 'tails',\n        result: result ? 'heads' : 'tails',\n        won,\n        payout: ethers.formatEther(payout),\n        timestamp: Number(timestamp),\n        txHash: '' // Would be available in the event context\n      };\n      if (onGamePlayed) {\n        onGamePlayed(game);\n      }\n    };\n    try {\n      this.contract.on('GamePlayed', handleGamePlayed);\n      return () => {\n        if (this.contract) {\n          this.contract.off('GamePlayed', handleGamePlayed);\n        }\n      };\n    } catch (error) {\n      console.error('Error setting up event listeners:', error);\n      return () => {};\n    }\n  }\n  disconnect() {\n    if (this.contract) {\n      this.contract.removeAllListeners();\n    }\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n  }\n\n  // Helper method to parse game result from transaction receipt\n  async parseGameResultFromReceipt(receipt) {\n    if (!this.contract) return null;\n    try {\n      // Look for GamePlayed events in the receipt\n      const logs = receipt.logs;\n      for (const log of logs) {\n        try {\n          const parsedLog = this.contract.interface.parseLog(log);\n          if (parsedLog && parsedLog.name === 'GamePlayed') {\n            return {\n              won: parsedLog.args.won,\n              betAmount: parsedLog.args.betAmount,\n              payout: parsedLog.args.payout\n            };\n          }\n        } catch (e) {\n          // Skip logs that don't match our contract interface\n          continue;\n        }\n      }\n      return null;\n    } catch (error) {\n      console.error('Error parsing game result from receipt:', error);\n      return null;\n    }\n  }\n}\n\n// Singleton instance\nexport const contractService = new ContractService();","map":{"version":3,"names":["ethers","CONTRACT_ABI","SHARDEUM_UNSTABLE","apiService","toast","ContractService","constructor","provider","signer","contract","initialize","Contract","contracts","shardFlip","isInitialized","flipCoin","amount","choice","success","error","betAmount","parseEther","choiceBool","betInfo","parseFloat","player","getAddress","minBet","MIN_BET","Error","formatEther","maxBet","MAX_BET","contractBalance","getContractBalance","payoutMultiplier","PAYOUT_MULTIPLIER","potentialPayout","BigInt","isPaused","paused","gasLimit","gasEstimate","estimateGas","value","gasError","console","warn","gasPrice","getFeeData","tx","receipt","wait","status","gameResult","parseGameResultFromReceipt","playerAddress","log","Promise","resolve","setTimeout","won","payout","result","updateGameResult","recentGames","getRecentGames","playerGame","find","game","toLowerCase","Math","abs","contractError","backendError","url","process","env","REACT_APP_API_URL","hasApiKey","REACT_APP_API_SECRET_KEY","txHash","hash","_error$message","_error$message2","_error$message3","_error$message4","_error$message5","errorMessage","code","message","includes","getPlayerStats","address","stats","totalGames","Number","totalWins","totalWagered","totalWon","winRate","netProfit","toString","limit","games","slice","map","index","id","timestamp","getGameStats","totalVolume","totalPayout","activeUsers","getLeaderboard","players","wins","wagered","getTopPlayers","waitForTransaction","_error$message6","parseGameEvents","fromBlock","filter","filters","GamePlayed","events","queryFilter","event","args","transactionHash","setupEventListeners","onGamePlayed","handleGamePlayed","on","off","disconnect","removeAllListeners","logs","parsedLog","interface","parseLog","name","e","contractService"],"sources":["/Users/nikhilkumar/Documents/Unstable/Shard-Flip/src/services/contractService.ts"],"sourcesContent":["import { ethers } from 'ethers';\nimport { GameResult, PlayerStats, GameStats, LeaderboardEntry, CoinSide } from '../types';\nimport { CONTRACT_ABI, SHARDEUM_UNSTABLE } from '../utils/constants';\nimport { apiService } from './apiService';\nimport toast from 'react-hot-toast';\n\nexport class ContractService {\n  private contract: ethers.Contract | null = null;\n  private provider: ethers.BrowserProvider | null = null;\n  private signer: ethers.JsonRpcSigner | null = null;\n\n  constructor(provider?: ethers.BrowserProvider, signer?: ethers.JsonRpcSigner) {\n    if (provider && signer) {\n      this.initialize(provider, signer);\n    }\n  }\n\n  initialize(provider: ethers.BrowserProvider, signer: ethers.JsonRpcSigner) {\n    this.provider = provider;\n    this.signer = signer;\n    this.contract = new ethers.Contract(\n      SHARDEUM_UNSTABLE.contracts.shardFlip,\n      CONTRACT_ABI,\n      signer\n    );\n  }\n\n  isInitialized(): boolean {\n    return this.contract !== null && this.signer !== null && this.provider !== null;\n  }\n\n  async flipCoin(amount: string, choice: CoinSide): Promise<{ success: boolean; txHash?: string; error?: string }> {\n    if (!this.isInitialized()) {\n      return { success: false, error: 'Contract not initialized' };\n    }\n\n    try {\n      const betAmount = ethers.parseEther(amount);\n      const choiceBool = choice === 'heads'; // true for heads, false for tails\n      \n      // Store bet info for fallback update\n      const betInfo = {\n        amount: parseFloat(amount),\n        choice: choice,\n        player: this.signer ? await this.signer.getAddress() : null\n      };\n\n      // Check minimum bet amount\n      const minBet = await this.contract!.MIN_BET();\n      if (betAmount < minBet) {\n        throw new Error(`Minimum bet is ${ethers.formatEther(minBet)} SHM`);\n      }\n\n      // Check maximum bet amount\n      const maxBet = await this.contract!.MAX_BET();\n      if (betAmount > maxBet) {\n        throw new Error(`Maximum bet is ${ethers.formatEther(maxBet)} SHM`);\n      }\n\n      // Check contract balance for potential payout\n      const contractBalance = await this.contract!.getContractBalance();\n      const payoutMultiplier = await this.contract!.PAYOUT_MULTIPLIER();\n      const potentialPayout = betAmount * payoutMultiplier / BigInt(100);\n      \n      if (contractBalance < potentialPayout) {\n        throw new Error('Contract has insufficient balance for this bet');\n      }\n\n      // Check if contract is paused\n      const isPaused = await this.contract!.paused();\n      if (isPaused) {\n        throw new Error('Contract is currently paused');\n      }\n\n      let gasLimit;\n      try {\n        // Estimate gas with a more conservative approach\n        const gasEstimate = await this.contract!.flipCoin.estimateGas(choiceBool, {\n          value: betAmount\n        });\n        gasLimit = gasEstimate * BigInt(150) / BigInt(100); // 50% buffer\n      } catch (gasError) {\n        console.warn('Gas estimation failed, using fallback:', gasError);\n        gasLimit = BigInt(500000); // Fallback gas limit\n      }\n\n      // Get current gas price\n      const gasPrice = await this.provider!.getFeeData();\n      \n      const tx = await this.contract!.flipCoin(choiceBool, {\n        value: betAmount,\n        gasLimit: gasLimit,\n        gasPrice: gasPrice.gasPrice\n      });\n\n      toast.success('Transaction sent! Waiting for confirmation...');\n      \n      const receipt = await tx.wait();\n      \n      if (receipt && receipt.status === 1) {\n        toast.success('Coin flip completed!');\n        \n        // Get the game result from transaction receipt\n        const gameResult = await this.parseGameResultFromReceipt(receipt);\n        \n        // Always attempt backend update after successful transaction\n        if (this.signer) {\n          const playerAddress = await this.signer.getAddress();\n          console.log('🎮 Updating backend for successful game by:', playerAddress);\n          console.log('💰 Bet amount:', betInfo.amount, 'SHM');\n          \n          try {\n            // First, get the actual game result from the blockchain\n            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s for blockchain to update\n            \n            if (gameResult) {\n              console.log('📊 Parsed game result:', {\n                won: gameResult.won,\n                betAmount: ethers.formatEther(gameResult.betAmount),\n                payout: ethers.formatEther(gameResult.payout)\n              });\n              \n              const result = await apiService.updateGameResult(\n                playerAddress,\n                gameResult.won ? 'win' : 'loss',\n                parseFloat(ethers.formatEther(gameResult.betAmount)),\n                gameResult.won ? parseFloat(ethers.formatEther(gameResult.payout)) : 0\n              );\n              console.log('✅ Backend update result:', result);\n            } else {\n              console.log('⚠️ Could not parse game result from receipt, checking contract directly...');\n              \n              // Fallback: Check contract for recent games\n              try {\n                const recentGames = await this.getRecentGames(5);\n                const playerGame = recentGames.find(game => \n                  game.player.toLowerCase() === playerAddress.toLowerCase() &&\n                  Math.abs(parseFloat(game.betAmount) - betInfo.amount) < 0.001\n                );\n                \n                if (playerGame) {\n                  console.log('🎯 Found matching game in contract:', playerGame);\n                  const result = await apiService.updateGameResult(\n                    playerAddress,\n                    playerGame.won ? 'win' : 'loss',\n                    parseFloat(playerGame.betAmount),\n                    parseFloat(playerGame.payout)\n                  );\n                  console.log('✅ Backend updated from contract data:', result);\n                } else {\n                  console.log('🔍 No matching game found, using bet amount as fallback');\n                  // Last resort: assume loss if we can't determine result\n                  const result = await apiService.updateGameResult(\n                    playerAddress,\n                    'loss', // Conservative assumption\n                    betInfo.amount,\n                    0\n                  );\n                  console.log('✅ Backend updated with fallback (assumed loss):', result);\n                }\n              } catch (contractError) {\n                console.error('Failed to get game from contract:', contractError);\n              }\n            }\n          } catch (backendError) {\n            console.error('❌ Failed to update backend:', backendError);\n            console.log('🔧 Backend error details:', {\n              url: process.env.REACT_APP_API_URL,\n              hasApiKey: !!process.env.REACT_APP_API_SECRET_KEY\n            });\n          }\n        }\n        \n        return { success: true, txHash: tx.hash };\n      } else {\n        throw new Error('Transaction failed');\n      }\n\n    } catch (error: any) {\n      console.error('Error flipping coin:', error);\n      \n      let errorMessage = 'Failed to flip coin';\n      \n      if (error.code === 'ACTION_REJECTED') {\n        errorMessage = 'Transaction rejected by user';\n      } else if (error.code === 'INSUFFICIENT_FUNDS') {\n        errorMessage = 'Insufficient funds for bet + gas';\n      } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        errorMessage = 'Cannot estimate gas - contract may be paused or have insufficient balance';\n      } else if (error.message?.includes('insufficient funds')) {\n        errorMessage = 'Insufficient SHM balance';\n      } else if (error.message?.includes('Minimum bet')) {\n        errorMessage = error.message;\n      } else if (error.message?.includes('Maximum bet')) {\n        errorMessage = error.message;\n      } else if (error.message?.includes('insufficient balance')) {\n        errorMessage = error.message;\n      } else if (error.message?.includes('paused')) {\n        errorMessage = error.message;\n      } else if (error.code === -32603) {\n        errorMessage = 'Network error - please try again';\n      }\n\n      toast.error(errorMessage);\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  async getPlayerStats(address: string): Promise<PlayerStats | null> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n\n    try {\n      const stats = await this.contract!.getPlayerStats(address);\n      \n      // The contract returns individual values\n      const totalGames = Number(stats[0]);\n      const totalWins = Number(stats[1]);\n      const totalWagered = ethers.formatEther(stats[2]);\n      const totalWon = ethers.formatEther(stats[3]);\n\n      return {\n        totalGames,\n        totalWins,\n        winRate: totalGames > 0 ? (totalWins / totalGames) * 100 : 0,\n        totalWagered,\n        totalWon,\n        netProfit: (parseFloat(totalWon) - parseFloat(totalWagered)).toString()\n      };\n\n    } catch (error) {\n      console.error('Error fetching player stats:', error);\n      // Return default stats instead of null to prevent UI issues\n      return {\n        totalGames: 0,\n        totalWins: 0,\n        winRate: 0,\n        totalWagered: '0',\n        totalWon: '0',\n        netProfit: '0'\n      };\n    }\n  }\n\n  async getRecentGames(limit: number = 50): Promise<GameResult[]> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n\n    try {\n      const games = await this.contract!.getRecentGames();\n      \n      return games.slice(0, limit).map((game: any, index: number) => ({\n        id: `${game.player}-${game.timestamp}-${index}`,\n        player: game.player,\n        betAmount: ethers.formatEther(game.betAmount),\n        choice: game.choice ? 'heads' : 'tails',\n        result: game.result ? 'heads' : 'tails',\n        won: game.won,\n        payout: ethers.formatEther(game.payout),\n        timestamp: Number(game.timestamp),\n        txHash: '' // This would need to be tracked separately or obtained from events\n      }));\n\n    } catch (error) {\n      console.error('Error fetching recent games:', error);\n      return [];\n    }\n  }\n\n  async getGameStats(): Promise<GameStats | null> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n\n    try {\n      const stats = await this.contract!.getGameStats();\n      \n      // The new contract returns individual values, not a struct\n      return {\n        totalGames: Number(stats[0]),\n        totalVolume: ethers.formatEther(stats[1]),\n        totalPayout: ethers.formatEther(stats[2]),\n        activeUsers: Number(stats[3])\n      };\n\n    } catch (error) {\n      console.error('Error fetching game stats:', error);\n      return null;\n    }\n  }\n\n  async getLeaderboard(limit: number = 10): Promise<LeaderboardEntry[]> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n\n    try {\n      const [players, wins, wagered] = await this.contract!.getTopPlayers(limit);\n      \n      return players.map((player: string, index: number) => ({\n        address: player,\n        wins: Number(wins[index]),\n        totalWagered: ethers.formatEther(wagered[index]),\n        netProfit: '0', // Would need additional calculation\n        winRate: 0 // Would need total games to calculate\n      }));\n    } catch (error) {\n      console.error('Error fetching leaderboard:', error);\n      return [];\n    }\n  }\n\n  async waitForTransaction(txHash: string): Promise<boolean> {\n    if (!this.provider) {\n      console.error('Provider not available for transaction waiting');\n      return false;\n    }\n\n    try {\n      console.log('⏳ Waiting for transaction confirmation:', txHash);\n\n      // Wait for 1 confirmation with 60 second timeout\n      const receipt = await this.provider.waitForTransaction(txHash, 1, 60000);\n\n      if (receipt) {\n        const success = receipt.status === 1;\n        console.log(success ? '✅ Transaction confirmed successfully' : '❌ Transaction failed');\n        return success;\n      } else {\n        console.warn('⚠️ Transaction receipt not received within timeout');\n        return false;\n      }\n    } catch (error: any) {\n      console.error('❌ Error waiting for transaction:', error);\n\n      // If it's a timeout error, don't treat it as complete failure\n      if (error.code === 'TIMEOUT' || error.message?.includes('timeout')) {\n        console.warn('⏰ Transaction confirmation timed out, but may still succeed');\n      }\n\n      return false;\n    }\n  }\n\n  // Utility method to parse game events (for real-time updates)\n  async parseGameEvents(fromBlock: number = 0): Promise<GameResult[]> {\n    if (!this.contract || !this.provider) return [];\n\n    try {\n      // This would parse GamePlayed events from the contract\n      // Implementation depends on the actual contract events\n      const filter = this.contract.filters.GamePlayed();\n      const events = await this.contract.queryFilter(filter, fromBlock);\n      \n      return events.map((event: any) => {\n        const args = event.args;\n        return {\n          id: `${args.player}-${args.timestamp}`,\n          player: args.player,\n          betAmount: ethers.formatEther(args.betAmount),\n          choice: args.choice ? 'heads' : 'tails',\n          result: args.result ? 'heads' : 'tails',\n          won: args.won,\n          payout: ethers.formatEther(args.payout),\n          timestamp: Number(args.timestamp),\n          txHash: event.transactionHash\n        };\n      });\n\n    } catch (error) {\n      console.error('Error parsing game events:', error);\n      return [];\n    }\n  }\n\n  // Listen for real-time game events\n  setupEventListeners(onGamePlayed?: (game: GameResult) => void): () => void {\n    if (!this.contract) {\n      return () => {};\n    }\n\n    const handleGamePlayed = (player: string, betAmount: bigint, choice: boolean, result: boolean, won: boolean, payout: bigint, timestamp: bigint) => {\n      const game: GameResult = {\n        id: `${player}-${timestamp}`,\n        player,\n        betAmount: ethers.formatEther(betAmount),\n        choice: choice ? 'heads' : 'tails',\n        result: result ? 'heads' : 'tails',\n        won,\n        payout: ethers.formatEther(payout),\n        timestamp: Number(timestamp),\n        txHash: '' // Would be available in the event context\n      };\n\n      if (onGamePlayed) {\n        onGamePlayed(game);\n      }\n    };\n\n    try {\n      this.contract.on('GamePlayed', handleGamePlayed);\n      \n      return () => {\n        if (this.contract) {\n          this.contract.off('GamePlayed', handleGamePlayed);\n        }\n      };\n    } catch (error) {\n      console.error('Error setting up event listeners:', error);\n      return () => {};\n    }\n  }\n\n  disconnect() {\n    if (this.contract) {\n      this.contract.removeAllListeners();\n    }\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n  }\n\n  // Helper method to parse game result from transaction receipt\n  private async parseGameResultFromReceipt(receipt: any): Promise<{ won: boolean; betAmount: bigint; payout: bigint } | null> {\n    if (!this.contract) return null;\n\n    try {\n      // Look for GamePlayed events in the receipt\n      const logs = receipt.logs;\n      \n      for (const log of logs) {\n        try {\n          const parsedLog = this.contract.interface.parseLog(log);\n          if (parsedLog && parsedLog.name === 'GamePlayed') {\n            return {\n              won: parsedLog.args.won,\n              betAmount: parsedLog.args.betAmount,\n              payout: parsedLog.args.payout\n            };\n          }\n        } catch (e) {\n          // Skip logs that don't match our contract interface\n          continue;\n        }\n      }\n      \n      return null;\n    } catch (error) {\n      console.error('Error parsing game result from receipt:', error);\n      return null;\n    }\n  }\n}\n\n// Singleton instance\nexport const contractService = new ContractService();"],"mappings":"AAAA,SAASA,MAAM,QAAQ,QAAQ;AAE/B,SAASC,YAAY,EAAEC,iBAAiB,QAAQ,oBAAoB;AACpE,SAASC,UAAU,QAAQ,cAAc;AACzC,OAAOC,KAAK,MAAM,iBAAiB;AAEnC,OAAO,MAAMC,eAAe,CAAC;EAK3BC,WAAWA,CAACC,QAAiC,EAAEC,MAA6B,EAAE;IAAA,KAJtEC,QAAQ,GAA2B,IAAI;IAAA,KACvCF,QAAQ,GAAkC,IAAI;IAAA,KAC9CC,MAAM,GAAgC,IAAI;IAGhD,IAAID,QAAQ,IAAIC,MAAM,EAAE;MACtB,IAAI,CAACE,UAAU,CAACH,QAAQ,EAAEC,MAAM,CAAC;IACnC;EACF;EAEAE,UAAUA,CAACH,QAAgC,EAAEC,MAA4B,EAAE;IACzE,IAAI,CAACD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,QAAQ,GAAG,IAAIT,MAAM,CAACW,QAAQ,CACjCT,iBAAiB,CAACU,SAAS,CAACC,SAAS,EACrCZ,YAAY,EACZO,MACF,CAAC;EACH;EAEAM,aAAaA,CAAA,EAAY;IACvB,OAAO,IAAI,CAACL,QAAQ,KAAK,IAAI,IAAI,IAAI,CAACD,MAAM,KAAK,IAAI,IAAI,IAAI,CAACD,QAAQ,KAAK,IAAI;EACjF;EAEA,MAAMQ,QAAQA,CAACC,MAAc,EAAEC,MAAgB,EAAkE;IAC/G,IAAI,CAAC,IAAI,CAACH,aAAa,CAAC,CAAC,EAAE;MACzB,OAAO;QAAEI,OAAO,EAAE,KAAK;QAAEC,KAAK,EAAE;MAA2B,CAAC;IAC9D;IAEA,IAAI;MACF,MAAMC,SAAS,GAAGpB,MAAM,CAACqB,UAAU,CAACL,MAAM,CAAC;MAC3C,MAAMM,UAAU,GAAGL,MAAM,KAAK,OAAO,CAAC,CAAC;;MAEvC;MACA,MAAMM,OAAO,GAAG;QACdP,MAAM,EAAEQ,UAAU,CAACR,MAAM,CAAC;QAC1BC,MAAM,EAAEA,MAAM;QACdQ,MAAM,EAAE,IAAI,CAACjB,MAAM,GAAG,MAAM,IAAI,CAACA,MAAM,CAACkB,UAAU,CAAC,CAAC,GAAG;MACzD,CAAC;;MAED;MACA,MAAMC,MAAM,GAAG,MAAM,IAAI,CAAClB,QAAQ,CAAEmB,OAAO,CAAC,CAAC;MAC7C,IAAIR,SAAS,GAAGO,MAAM,EAAE;QACtB,MAAM,IAAIE,KAAK,CAAC,kBAAkB7B,MAAM,CAAC8B,WAAW,CAACH,MAAM,CAAC,MAAM,CAAC;MACrE;;MAEA;MACA,MAAMI,MAAM,GAAG,MAAM,IAAI,CAACtB,QAAQ,CAAEuB,OAAO,CAAC,CAAC;MAC7C,IAAIZ,SAAS,GAAGW,MAAM,EAAE;QACtB,MAAM,IAAIF,KAAK,CAAC,kBAAkB7B,MAAM,CAAC8B,WAAW,CAACC,MAAM,CAAC,MAAM,CAAC;MACrE;;MAEA;MACA,MAAME,eAAe,GAAG,MAAM,IAAI,CAACxB,QAAQ,CAAEyB,kBAAkB,CAAC,CAAC;MACjE,MAAMC,gBAAgB,GAAG,MAAM,IAAI,CAAC1B,QAAQ,CAAE2B,iBAAiB,CAAC,CAAC;MACjE,MAAMC,eAAe,GAAGjB,SAAS,GAAGe,gBAAgB,GAAGG,MAAM,CAAC,GAAG,CAAC;MAElE,IAAIL,eAAe,GAAGI,eAAe,EAAE;QACrC,MAAM,IAAIR,KAAK,CAAC,gDAAgD,CAAC;MACnE;;MAEA;MACA,MAAMU,QAAQ,GAAG,MAAM,IAAI,CAAC9B,QAAQ,CAAE+B,MAAM,CAAC,CAAC;MAC9C,IAAID,QAAQ,EAAE;QACZ,MAAM,IAAIV,KAAK,CAAC,8BAA8B,CAAC;MACjD;MAEA,IAAIY,QAAQ;MACZ,IAAI;QACF;QACA,MAAMC,WAAW,GAAG,MAAM,IAAI,CAACjC,QAAQ,CAAEM,QAAQ,CAAC4B,WAAW,CAACrB,UAAU,EAAE;UACxEsB,KAAK,EAAExB;QACT,CAAC,CAAC;QACFqB,QAAQ,GAAGC,WAAW,GAAGJ,MAAM,CAAC,GAAG,CAAC,GAAGA,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;MACtD,CAAC,CAAC,OAAOO,QAAQ,EAAE;QACjBC,OAAO,CAACC,IAAI,CAAC,wCAAwC,EAAEF,QAAQ,CAAC;QAChEJ,QAAQ,GAAGH,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;MAC7B;;MAEA;MACA,MAAMU,QAAQ,GAAG,MAAM,IAAI,CAACzC,QAAQ,CAAE0C,UAAU,CAAC,CAAC;MAElD,MAAMC,EAAE,GAAG,MAAM,IAAI,CAACzC,QAAQ,CAAEM,QAAQ,CAACO,UAAU,EAAE;QACnDsB,KAAK,EAAExB,SAAS;QAChBqB,QAAQ,EAAEA,QAAQ;QAClBO,QAAQ,EAAEA,QAAQ,CAACA;MACrB,CAAC,CAAC;MAEF5C,KAAK,CAACc,OAAO,CAAC,+CAA+C,CAAC;MAE9D,MAAMiC,OAAO,GAAG,MAAMD,EAAE,CAACE,IAAI,CAAC,CAAC;MAE/B,IAAID,OAAO,IAAIA,OAAO,CAACE,MAAM,KAAK,CAAC,EAAE;QACnCjD,KAAK,CAACc,OAAO,CAAC,sBAAsB,CAAC;;QAErC;QACA,MAAMoC,UAAU,GAAG,MAAM,IAAI,CAACC,0BAA0B,CAACJ,OAAO,CAAC;;QAEjE;QACA,IAAI,IAAI,CAAC3C,MAAM,EAAE;UACf,MAAMgD,aAAa,GAAG,MAAM,IAAI,CAAChD,MAAM,CAACkB,UAAU,CAAC,CAAC;UACpDoB,OAAO,CAACW,GAAG,CAAC,6CAA6C,EAAED,aAAa,CAAC;UACzEV,OAAO,CAACW,GAAG,CAAC,gBAAgB,EAAElC,OAAO,CAACP,MAAM,EAAE,KAAK,CAAC;UAEpD,IAAI;YACF;YACA,MAAM,IAAI0C,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;;YAEzD,IAAIL,UAAU,EAAE;cACdR,OAAO,CAACW,GAAG,CAAC,wBAAwB,EAAE;gBACpCI,GAAG,EAAEP,UAAU,CAACO,GAAG;gBACnBzC,SAAS,EAAEpB,MAAM,CAAC8B,WAAW,CAACwB,UAAU,CAAClC,SAAS,CAAC;gBACnD0C,MAAM,EAAE9D,MAAM,CAAC8B,WAAW,CAACwB,UAAU,CAACQ,MAAM;cAC9C,CAAC,CAAC;cAEF,MAAMC,MAAM,GAAG,MAAM5D,UAAU,CAAC6D,gBAAgB,CAC9CR,aAAa,EACbF,UAAU,CAACO,GAAG,GAAG,KAAK,GAAG,MAAM,EAC/BrC,UAAU,CAACxB,MAAM,CAAC8B,WAAW,CAACwB,UAAU,CAAClC,SAAS,CAAC,CAAC,EACpDkC,UAAU,CAACO,GAAG,GAAGrC,UAAU,CAACxB,MAAM,CAAC8B,WAAW,CAACwB,UAAU,CAACQ,MAAM,CAAC,CAAC,GAAG,CACvE,CAAC;cACDhB,OAAO,CAACW,GAAG,CAAC,0BAA0B,EAAEM,MAAM,CAAC;YACjD,CAAC,MAAM;cACLjB,OAAO,CAACW,GAAG,CAAC,4EAA4E,CAAC;;cAEzF;cACA,IAAI;gBACF,MAAMQ,WAAW,GAAG,MAAM,IAAI,CAACC,cAAc,CAAC,CAAC,CAAC;gBAChD,MAAMC,UAAU,GAAGF,WAAW,CAACG,IAAI,CAACC,IAAI,IACtCA,IAAI,CAAC5C,MAAM,CAAC6C,WAAW,CAAC,CAAC,KAAKd,aAAa,CAACc,WAAW,CAAC,CAAC,IACzDC,IAAI,CAACC,GAAG,CAAChD,UAAU,CAAC6C,IAAI,CAACjD,SAAS,CAAC,GAAGG,OAAO,CAACP,MAAM,CAAC,GAAG,KAC1D,CAAC;gBAED,IAAImD,UAAU,EAAE;kBACdrB,OAAO,CAACW,GAAG,CAAC,qCAAqC,EAAEU,UAAU,CAAC;kBAC9D,MAAMJ,MAAM,GAAG,MAAM5D,UAAU,CAAC6D,gBAAgB,CAC9CR,aAAa,EACbW,UAAU,CAACN,GAAG,GAAG,KAAK,GAAG,MAAM,EAC/BrC,UAAU,CAAC2C,UAAU,CAAC/C,SAAS,CAAC,EAChCI,UAAU,CAAC2C,UAAU,CAACL,MAAM,CAC9B,CAAC;kBACDhB,OAAO,CAACW,GAAG,CAAC,uCAAuC,EAAEM,MAAM,CAAC;gBAC9D,CAAC,MAAM;kBACLjB,OAAO,CAACW,GAAG,CAAC,yDAAyD,CAAC;kBACtE;kBACA,MAAMM,MAAM,GAAG,MAAM5D,UAAU,CAAC6D,gBAAgB,CAC9CR,aAAa,EACb,MAAM;kBAAE;kBACRjC,OAAO,CAACP,MAAM,EACd,CACF,CAAC;kBACD8B,OAAO,CAACW,GAAG,CAAC,iDAAiD,EAAEM,MAAM,CAAC;gBACxE;cACF,CAAC,CAAC,OAAOU,aAAa,EAAE;gBACtB3B,OAAO,CAAC3B,KAAK,CAAC,mCAAmC,EAAEsD,aAAa,CAAC;cACnE;YACF;UACF,CAAC,CAAC,OAAOC,YAAY,EAAE;YACrB5B,OAAO,CAAC3B,KAAK,CAAC,6BAA6B,EAAEuD,YAAY,CAAC;YAC1D5B,OAAO,CAACW,GAAG,CAAC,2BAA2B,EAAE;cACvCkB,GAAG,EAAEC,OAAO,CAACC,GAAG,CAACC,iBAAiB;cAClCC,SAAS,EAAE,CAAC,CAACH,OAAO,CAACC,GAAG,CAACG;YAC3B,CAAC,CAAC;UACJ;QACF;QAEA,OAAO;UAAE9D,OAAO,EAAE,IAAI;UAAE+D,MAAM,EAAE/B,EAAE,CAACgC;QAAK,CAAC;MAC3C,CAAC,MAAM;QACL,MAAM,IAAIrD,KAAK,CAAC,oBAAoB,CAAC;MACvC;IAEF,CAAC,CAAC,OAAOV,KAAU,EAAE;MAAA,IAAAgE,cAAA,EAAAC,eAAA,EAAAC,eAAA,EAAAC,eAAA,EAAAC,eAAA;MACnBzC,OAAO,CAAC3B,KAAK,CAAC,sBAAsB,EAAEA,KAAK,CAAC;MAE5C,IAAIqE,YAAY,GAAG,qBAAqB;MAExC,IAAIrE,KAAK,CAACsE,IAAI,KAAK,iBAAiB,EAAE;QACpCD,YAAY,GAAG,8BAA8B;MAC/C,CAAC,MAAM,IAAIrE,KAAK,CAACsE,IAAI,KAAK,oBAAoB,EAAE;QAC9CD,YAAY,GAAG,kCAAkC;MACnD,CAAC,MAAM,IAAIrE,KAAK,CAACsE,IAAI,KAAK,yBAAyB,EAAE;QACnDD,YAAY,GAAG,2EAA2E;MAC5F,CAAC,MAAM,KAAAL,cAAA,GAAIhE,KAAK,CAACuE,OAAO,cAAAP,cAAA,eAAbA,cAAA,CAAeQ,QAAQ,CAAC,oBAAoB,CAAC,EAAE;QACxDH,YAAY,GAAG,0BAA0B;MAC3C,CAAC,MAAM,KAAAJ,eAAA,GAAIjE,KAAK,CAACuE,OAAO,cAAAN,eAAA,eAAbA,eAAA,CAAeO,QAAQ,CAAC,aAAa,CAAC,EAAE;QACjDH,YAAY,GAAGrE,KAAK,CAACuE,OAAO;MAC9B,CAAC,MAAM,KAAAL,eAAA,GAAIlE,KAAK,CAACuE,OAAO,cAAAL,eAAA,eAAbA,eAAA,CAAeM,QAAQ,CAAC,aAAa,CAAC,EAAE;QACjDH,YAAY,GAAGrE,KAAK,CAACuE,OAAO;MAC9B,CAAC,MAAM,KAAAJ,eAAA,GAAInE,KAAK,CAACuE,OAAO,cAAAJ,eAAA,eAAbA,eAAA,CAAeK,QAAQ,CAAC,sBAAsB,CAAC,EAAE;QAC1DH,YAAY,GAAGrE,KAAK,CAACuE,OAAO;MAC9B,CAAC,MAAM,KAAAH,eAAA,GAAIpE,KAAK,CAACuE,OAAO,cAAAH,eAAA,eAAbA,eAAA,CAAeI,QAAQ,CAAC,QAAQ,CAAC,EAAE;QAC5CH,YAAY,GAAGrE,KAAK,CAACuE,OAAO;MAC9B,CAAC,MAAM,IAAIvE,KAAK,CAACsE,IAAI,KAAK,CAAC,KAAK,EAAE;QAChCD,YAAY,GAAG,kCAAkC;MACnD;MAEApF,KAAK,CAACe,KAAK,CAACqE,YAAY,CAAC;MACzB,OAAO;QAAEtE,OAAO,EAAE,KAAK;QAAEC,KAAK,EAAEqE;MAAa,CAAC;IAChD;EACF;EAEA,MAAMI,cAAcA,CAACC,OAAe,EAA+B;IACjE,IAAI,CAAC,IAAI,CAAC/E,aAAa,CAAC,CAAC,EAAE;MACzBgC,OAAO,CAAC3B,KAAK,CAAC,0BAA0B,CAAC;MACzC,OAAO,IAAI;IACb;IAEA,IAAI;MACF,MAAM2E,KAAK,GAAG,MAAM,IAAI,CAACrF,QAAQ,CAAEmF,cAAc,CAACC,OAAO,CAAC;;MAE1D;MACA,MAAME,UAAU,GAAGC,MAAM,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC;MACnC,MAAMG,SAAS,GAAGD,MAAM,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC;MAClC,MAAMI,YAAY,GAAGlG,MAAM,CAAC8B,WAAW,CAACgE,KAAK,CAAC,CAAC,CAAC,CAAC;MACjD,MAAMK,QAAQ,GAAGnG,MAAM,CAAC8B,WAAW,CAACgE,KAAK,CAAC,CAAC,CAAC,CAAC;MAE7C,OAAO;QACLC,UAAU;QACVE,SAAS;QACTG,OAAO,EAAEL,UAAU,GAAG,CAAC,GAAIE,SAAS,GAAGF,UAAU,GAAI,GAAG,GAAG,CAAC;QAC5DG,YAAY;QACZC,QAAQ;QACRE,SAAS,EAAE,CAAC7E,UAAU,CAAC2E,QAAQ,CAAC,GAAG3E,UAAU,CAAC0E,YAAY,CAAC,EAAEI,QAAQ,CAAC;MACxE,CAAC;IAEH,CAAC,CAAC,OAAOnF,KAAK,EAAE;MACd2B,OAAO,CAAC3B,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD;MACA,OAAO;QACL4E,UAAU,EAAE,CAAC;QACbE,SAAS,EAAE,CAAC;QACZG,OAAO,EAAE,CAAC;QACVF,YAAY,EAAE,GAAG;QACjBC,QAAQ,EAAE,GAAG;QACbE,SAAS,EAAE;MACb,CAAC;IACH;EACF;EAEA,MAAMnC,cAAcA,CAACqC,KAAa,GAAG,EAAE,EAAyB;IAC9D,IAAI,CAAC,IAAI,CAACzF,aAAa,CAAC,CAAC,EAAE;MACzBgC,OAAO,CAAC3B,KAAK,CAAC,0BAA0B,CAAC;MACzC,OAAO,EAAE;IACX;IAEA,IAAI;MACF,MAAMqF,KAAK,GAAG,MAAM,IAAI,CAAC/F,QAAQ,CAAEyD,cAAc,CAAC,CAAC;MAEnD,OAAOsC,KAAK,CAACC,KAAK,CAAC,CAAC,EAAEF,KAAK,CAAC,CAACG,GAAG,CAAC,CAACrC,IAAS,EAAEsC,KAAa,MAAM;QAC9DC,EAAE,EAAE,GAAGvC,IAAI,CAAC5C,MAAM,IAAI4C,IAAI,CAACwC,SAAS,IAAIF,KAAK,EAAE;QAC/ClF,MAAM,EAAE4C,IAAI,CAAC5C,MAAM;QACnBL,SAAS,EAAEpB,MAAM,CAAC8B,WAAW,CAACuC,IAAI,CAACjD,SAAS,CAAC;QAC7CH,MAAM,EAAEoD,IAAI,CAACpD,MAAM,GAAG,OAAO,GAAG,OAAO;QACvC8C,MAAM,EAAEM,IAAI,CAACN,MAAM,GAAG,OAAO,GAAG,OAAO;QACvCF,GAAG,EAAEQ,IAAI,CAACR,GAAG;QACbC,MAAM,EAAE9D,MAAM,CAAC8B,WAAW,CAACuC,IAAI,CAACP,MAAM,CAAC;QACvC+C,SAAS,EAAEb,MAAM,CAAC3B,IAAI,CAACwC,SAAS,CAAC;QACjC5B,MAAM,EAAE,EAAE,CAAC;MACb,CAAC,CAAC,CAAC;IAEL,CAAC,CAAC,OAAO9D,KAAK,EAAE;MACd2B,OAAO,CAAC3B,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,OAAO,EAAE;IACX;EACF;EAEA,MAAM2F,YAAYA,CAAA,EAA8B;IAC9C,IAAI,CAAC,IAAI,CAAChG,aAAa,CAAC,CAAC,EAAE;MACzBgC,OAAO,CAAC3B,KAAK,CAAC,0BAA0B,CAAC;MACzC,OAAO,IAAI;IACb;IAEA,IAAI;MACF,MAAM2E,KAAK,GAAG,MAAM,IAAI,CAACrF,QAAQ,CAAEqG,YAAY,CAAC,CAAC;;MAEjD;MACA,OAAO;QACLf,UAAU,EAAEC,MAAM,CAACF,KAAK,CAAC,CAAC,CAAC,CAAC;QAC5BiB,WAAW,EAAE/G,MAAM,CAAC8B,WAAW,CAACgE,KAAK,CAAC,CAAC,CAAC,CAAC;QACzCkB,WAAW,EAAEhH,MAAM,CAAC8B,WAAW,CAACgE,KAAK,CAAC,CAAC,CAAC,CAAC;QACzCmB,WAAW,EAAEjB,MAAM,CAACF,KAAK,CAAC,CAAC,CAAC;MAC9B,CAAC;IAEH,CAAC,CAAC,OAAO3E,KAAK,EAAE;MACd2B,OAAO,CAAC3B,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;MAClD,OAAO,IAAI;IACb;EACF;EAEA,MAAM+F,cAAcA,CAACX,KAAa,GAAG,EAAE,EAA+B;IACpE,IAAI,CAAC,IAAI,CAACzF,aAAa,CAAC,CAAC,EAAE;MACzBgC,OAAO,CAAC3B,KAAK,CAAC,0BAA0B,CAAC;MACzC,OAAO,EAAE;IACX;IAEA,IAAI;MACF,MAAM,CAACgG,OAAO,EAAEC,IAAI,EAAEC,OAAO,CAAC,GAAG,MAAM,IAAI,CAAC5G,QAAQ,CAAE6G,aAAa,CAACf,KAAK,CAAC;MAE1E,OAAOY,OAAO,CAACT,GAAG,CAAC,CAACjF,MAAc,EAAEkF,KAAa,MAAM;QACrDd,OAAO,EAAEpE,MAAM;QACf2F,IAAI,EAAEpB,MAAM,CAACoB,IAAI,CAACT,KAAK,CAAC,CAAC;QACzBT,YAAY,EAAElG,MAAM,CAAC8B,WAAW,CAACuF,OAAO,CAACV,KAAK,CAAC,CAAC;QAChDN,SAAS,EAAE,GAAG;QAAE;QAChBD,OAAO,EAAE,CAAC,CAAC;MACb,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,OAAOjF,KAAK,EAAE;MACd2B,OAAO,CAAC3B,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;MACnD,OAAO,EAAE;IACX;EACF;EAEA,MAAMoG,kBAAkBA,CAACtC,MAAc,EAAoB;IACzD,IAAI,CAAC,IAAI,CAAC1E,QAAQ,EAAE;MAClBuC,OAAO,CAAC3B,KAAK,CAAC,gDAAgD,CAAC;MAC/D,OAAO,KAAK;IACd;IAEA,IAAI;MACF2B,OAAO,CAACW,GAAG,CAAC,yCAAyC,EAAEwB,MAAM,CAAC;;MAE9D;MACA,MAAM9B,OAAO,GAAG,MAAM,IAAI,CAAC5C,QAAQ,CAACgH,kBAAkB,CAACtC,MAAM,EAAE,CAAC,EAAE,KAAK,CAAC;MAExE,IAAI9B,OAAO,EAAE;QACX,MAAMjC,OAAO,GAAGiC,OAAO,CAACE,MAAM,KAAK,CAAC;QACpCP,OAAO,CAACW,GAAG,CAACvC,OAAO,GAAG,sCAAsC,GAAG,sBAAsB,CAAC;QACtF,OAAOA,OAAO;MAChB,CAAC,MAAM;QACL4B,OAAO,CAACC,IAAI,CAAC,oDAAoD,CAAC;QAClE,OAAO,KAAK;MACd;IACF,CAAC,CAAC,OAAO5B,KAAU,EAAE;MAAA,IAAAqG,eAAA;MACnB1E,OAAO,CAAC3B,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;;MAExD;MACA,IAAIA,KAAK,CAACsE,IAAI,KAAK,SAAS,KAAA+B,eAAA,GAAIrG,KAAK,CAACuE,OAAO,cAAA8B,eAAA,eAAbA,eAAA,CAAe7B,QAAQ,CAAC,SAAS,CAAC,EAAE;QAClE7C,OAAO,CAACC,IAAI,CAAC,6DAA6D,CAAC;MAC7E;MAEA,OAAO,KAAK;IACd;EACF;;EAEA;EACA,MAAM0E,eAAeA,CAACC,SAAiB,GAAG,CAAC,EAAyB;IAClE,IAAI,CAAC,IAAI,CAACjH,QAAQ,IAAI,CAAC,IAAI,CAACF,QAAQ,EAAE,OAAO,EAAE;IAE/C,IAAI;MACF;MACA;MACA,MAAMoH,MAAM,GAAG,IAAI,CAAClH,QAAQ,CAACmH,OAAO,CAACC,UAAU,CAAC,CAAC;MACjD,MAAMC,MAAM,GAAG,MAAM,IAAI,CAACrH,QAAQ,CAACsH,WAAW,CAACJ,MAAM,EAAED,SAAS,CAAC;MAEjE,OAAOI,MAAM,CAACpB,GAAG,CAAEsB,KAAU,IAAK;QAChC,MAAMC,IAAI,GAAGD,KAAK,CAACC,IAAI;QACvB,OAAO;UACLrB,EAAE,EAAE,GAAGqB,IAAI,CAACxG,MAAM,IAAIwG,IAAI,CAACpB,SAAS,EAAE;UACtCpF,MAAM,EAAEwG,IAAI,CAACxG,MAAM;UACnBL,SAAS,EAAEpB,MAAM,CAAC8B,WAAW,CAACmG,IAAI,CAAC7G,SAAS,CAAC;UAC7CH,MAAM,EAAEgH,IAAI,CAAChH,MAAM,GAAG,OAAO,GAAG,OAAO;UACvC8C,MAAM,EAAEkE,IAAI,CAAClE,MAAM,GAAG,OAAO,GAAG,OAAO;UACvCF,GAAG,EAAEoE,IAAI,CAACpE,GAAG;UACbC,MAAM,EAAE9D,MAAM,CAAC8B,WAAW,CAACmG,IAAI,CAACnE,MAAM,CAAC;UACvC+C,SAAS,EAAEb,MAAM,CAACiC,IAAI,CAACpB,SAAS,CAAC;UACjC5B,MAAM,EAAE+C,KAAK,CAACE;QAChB,CAAC;MACH,CAAC,CAAC;IAEJ,CAAC,CAAC,OAAO/G,KAAK,EAAE;MACd2B,OAAO,CAAC3B,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;MAClD,OAAO,EAAE;IACX;EACF;;EAEA;EACAgH,mBAAmBA,CAACC,YAAyC,EAAc;IACzE,IAAI,CAAC,IAAI,CAAC3H,QAAQ,EAAE;MAClB,OAAO,MAAM,CAAC,CAAC;IACjB;IAEA,MAAM4H,gBAAgB,GAAGA,CAAC5G,MAAc,EAAEL,SAAiB,EAAEH,MAAe,EAAE8C,MAAe,EAAEF,GAAY,EAAEC,MAAc,EAAE+C,SAAiB,KAAK;MACjJ,MAAMxC,IAAgB,GAAG;QACvBuC,EAAE,EAAE,GAAGnF,MAAM,IAAIoF,SAAS,EAAE;QAC5BpF,MAAM;QACNL,SAAS,EAAEpB,MAAM,CAAC8B,WAAW,CAACV,SAAS,CAAC;QACxCH,MAAM,EAAEA,MAAM,GAAG,OAAO,GAAG,OAAO;QAClC8C,MAAM,EAAEA,MAAM,GAAG,OAAO,GAAG,OAAO;QAClCF,GAAG;QACHC,MAAM,EAAE9D,MAAM,CAAC8B,WAAW,CAACgC,MAAM,CAAC;QAClC+C,SAAS,EAAEb,MAAM,CAACa,SAAS,CAAC;QAC5B5B,MAAM,EAAE,EAAE,CAAC;MACb,CAAC;MAED,IAAImD,YAAY,EAAE;QAChBA,YAAY,CAAC/D,IAAI,CAAC;MACpB;IACF,CAAC;IAED,IAAI;MACF,IAAI,CAAC5D,QAAQ,CAAC6H,EAAE,CAAC,YAAY,EAAED,gBAAgB,CAAC;MAEhD,OAAO,MAAM;QACX,IAAI,IAAI,CAAC5H,QAAQ,EAAE;UACjB,IAAI,CAACA,QAAQ,CAAC8H,GAAG,CAAC,YAAY,EAAEF,gBAAgB,CAAC;QACnD;MACF,CAAC;IACH,CAAC,CAAC,OAAOlH,KAAK,EAAE;MACd2B,OAAO,CAAC3B,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MACzD,OAAO,MAAM,CAAC,CAAC;IACjB;EACF;EAEAqH,UAAUA,CAAA,EAAG;IACX,IAAI,IAAI,CAAC/H,QAAQ,EAAE;MACjB,IAAI,CAACA,QAAQ,CAACgI,kBAAkB,CAAC,CAAC;IACpC;IACA,IAAI,CAAChI,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACF,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACC,MAAM,GAAG,IAAI;EACpB;;EAEA;EACA,MAAc+C,0BAA0BA,CAACJ,OAAY,EAAuE;IAC1H,IAAI,CAAC,IAAI,CAAC1C,QAAQ,EAAE,OAAO,IAAI;IAE/B,IAAI;MACF;MACA,MAAMiI,IAAI,GAAGvF,OAAO,CAACuF,IAAI;MAEzB,KAAK,MAAMjF,GAAG,IAAIiF,IAAI,EAAE;QACtB,IAAI;UACF,MAAMC,SAAS,GAAG,IAAI,CAAClI,QAAQ,CAACmI,SAAS,CAACC,QAAQ,CAACpF,GAAG,CAAC;UACvD,IAAIkF,SAAS,IAAIA,SAAS,CAACG,IAAI,KAAK,YAAY,EAAE;YAChD,OAAO;cACLjF,GAAG,EAAE8E,SAAS,CAACV,IAAI,CAACpE,GAAG;cACvBzC,SAAS,EAAEuH,SAAS,CAACV,IAAI,CAAC7G,SAAS;cACnC0C,MAAM,EAAE6E,SAAS,CAACV,IAAI,CAACnE;YACzB,CAAC;UACH;QACF,CAAC,CAAC,OAAOiF,CAAC,EAAE;UACV;UACA;QACF;MACF;MAEA,OAAO,IAAI;IACb,CAAC,CAAC,OAAO5H,KAAK,EAAE;MACd2B,OAAO,CAAC3B,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;MAC/D,OAAO,IAAI;IACb;EACF;AACF;;AAEA;AACA,OAAO,MAAM6H,eAAe,GAAG,IAAI3I,eAAe,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}