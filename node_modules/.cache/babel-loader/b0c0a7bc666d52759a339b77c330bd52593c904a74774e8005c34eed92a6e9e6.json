{"ast":null,"code":"import { ethers } from 'ethers';\nimport { CONTRACT_ABI, SHARDEUM_UNSTABLE } from '../utils/constants';\nimport { apiService } from './apiService';\nimport toast from 'react-hot-toast';\nexport class ContractService {\n  constructor(provider, signer) {\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n    if (provider && signer) {\n      this.initialize(provider, signer);\n    }\n  }\n  initialize(provider, signer) {\n    this.provider = provider;\n    this.signer = signer;\n    this.contract = new ethers.Contract(SHARDEUM_UNSTABLE.contracts.shardFlip, CONTRACT_ABI, signer);\n  }\n  isInitialized() {\n    return this.contract !== null && this.signer !== null && this.provider !== null;\n  }\n  async flipCoin(amount, choice) {\n    if (!this.isInitialized()) {\n      return {\n        success: false,\n        error: 'Contract not initialized'\n      };\n    }\n    try {\n      const betAmount = ethers.parseEther(amount);\n      const choiceBool = choice === 'heads'; // true for heads, false for tails\n\n      // Store bet info for fallback update\n      const betInfo = {\n        amount: parseFloat(amount),\n        choice: choice,\n        player: this.signer ? await this.signer.getAddress() : null\n      };\n\n      // Check minimum bet amount\n      const minBet = await this.contract.MIN_BET();\n      if (betAmount < minBet) {\n        throw new Error(`Minimum bet is ${ethers.formatEther(minBet)} SHM`);\n      }\n\n      // Check maximum bet amount\n      const maxBet = await this.contract.MAX_BET();\n      if (betAmount > maxBet) {\n        throw new Error(`Maximum bet is ${ethers.formatEther(maxBet)} SHM`);\n      }\n\n      // Check contract balance for potential payout\n      const contractBalance = await this.contract.getContractBalance();\n      const payoutMultiplier = await this.contract.PAYOUT_MULTIPLIER();\n      const potentialPayout = betAmount * payoutMultiplier / BigInt(100);\n      if (contractBalance < potentialPayout) {\n        throw new Error('Contract has insufficient balance for this bet');\n      }\n\n      // Check if contract is paused\n      const isPaused = await this.contract.paused();\n      if (isPaused) {\n        throw new Error('Contract is currently paused');\n      }\n      let gasLimit;\n      try {\n        // Estimate gas with a more conservative approach\n        const gasEstimate = await this.contract.flipCoin.estimateGas(choiceBool, {\n          value: betAmount\n        });\n        gasLimit = gasEstimate * BigInt(150) / BigInt(100); // 50% buffer\n      } catch (gasError) {\n        console.warn('Gas estimation failed, using fallback:', gasError);\n        gasLimit = BigInt(500000); // Fallback gas limit\n      }\n\n      // Get current gas price with fallback for networks that don't support EIP-1559\n      let txOptions = {\n        value: betAmount,\n        gasLimit: gasLimit\n      };\n      try {\n        const feeData = await this.provider.getFeeData();\n        if (feeData.gasPrice) {\n          txOptions.gasPrice = feeData.gasPrice;\n        }\n      } catch (gasError) {\n        console.warn('Failed to get fee data, using default gas settings:', gasError);\n      }\n      const tx = await this.contract.flipCoin(choiceBool, txOptions);\n      toast.success('Transaction sent! Waiting for confirmation...');\n      const receipt = await tx.wait();\n      if (receipt && receipt.status === 1) {\n        toast.success('Coin flip completed!');\n\n        // Get the game result from transaction receipt\n        const gameResult = await this.parseGameResultFromReceipt(receipt);\n\n        // Always attempt backend update after successful transaction\n        if (this.signer) {\n          const playerAddress = await this.signer.getAddress();\n          console.log('🎮 Updating backend for successful game by:', playerAddress);\n          console.log('💰 Bet amount:', betInfo.amount, 'SHM');\n          try {\n            // First, get the actual game result from the blockchain\n            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s for blockchain to update\n\n            if (gameResult) {\n              console.log('📊 Parsed game result:', {\n                won: gameResult.won,\n                betAmount: ethers.formatEther(gameResult.betAmount),\n                payout: ethers.formatEther(gameResult.payout)\n              });\n              const result = await apiService.updateGameResult(playerAddress, gameResult.won ? 'win' : 'loss', parseFloat(ethers.formatEther(gameResult.betAmount)), gameResult.won ? parseFloat(ethers.formatEther(gameResult.payout)) : 0);\n              console.log('✅ Backend update result:', result);\n            } else {\n              console.log('⚠️ Could not parse game result from receipt, checking contract directly...');\n\n              // Fallback: Check contract for recent games\n              try {\n                const recentGames = await this.getRecentGames(5);\n                const playerGame = recentGames.find(game => game.player.toLowerCase() === playerAddress.toLowerCase() && Math.abs(parseFloat(game.betAmount) - betInfo.amount) < 0.001);\n                if (playerGame) {\n                  console.log('🎯 Found matching game in contract:', playerGame);\n                  const result = await apiService.updateGameResult(playerAddress, playerGame.won ? 'win' : 'loss', parseFloat(playerGame.betAmount), parseFloat(playerGame.payout));\n                  console.log('✅ Backend updated from contract data:', result);\n                } else {\n                  console.log('🔍 No matching game found, using bet amount as fallback');\n                  // Last resort: assume loss if we can't determine result\n                  const result = await apiService.updateGameResult(playerAddress, 'loss',\n                  // Conservative assumption\n                  betInfo.amount, 0);\n                  console.log('✅ Backend updated with fallback (assumed loss):', result);\n                }\n              } catch (contractError) {\n                console.error('Failed to get game from contract:', contractError);\n              }\n            }\n          } catch (backendError) {\n            console.error('❌ Failed to update backend:', backendError);\n            console.log('🔧 Backend error details:', {\n              url: process.env.REACT_APP_API_URL,\n              hasApiKey: !!process.env.REACT_APP_API_SECRET_KEY\n            });\n          }\n        }\n        return {\n          success: true,\n          txHash: tx.hash\n        };\n      } else {\n        throw new Error('Transaction failed');\n      }\n    } catch (error) {\n      var _error$message, _error$message2, _error$message3, _error$message4, _error$message5;\n      console.error('❌ Error flipping coin:', error);\n      console.error('❌ Error details:', {\n        message: error.message,\n        code: error.code,\n        reason: error.reason,\n        data: error.data\n      });\n      let errorMessage = 'Failed to flip coin';\n      if (error.code === 'ACTION_REJECTED') {\n        errorMessage = 'Transaction rejected by user';\n      } else if (error.code === 'INSUFFICIENT_FUNDS') {\n        errorMessage = 'Insufficient funds for bet + gas';\n      } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        errorMessage = 'Cannot estimate gas - contract may be paused or have insufficient balance';\n      } else if ((_error$message = error.message) !== null && _error$message !== void 0 && _error$message.includes('insufficient funds')) {\n        errorMessage = 'Insufficient SHM balance';\n      } else if ((_error$message2 = error.message) !== null && _error$message2 !== void 0 && _error$message2.includes('Minimum bet')) {\n        errorMessage = error.message;\n      } else if ((_error$message3 = error.message) !== null && _error$message3 !== void 0 && _error$message3.includes('Maximum bet')) {\n        errorMessage = error.message;\n      } else if ((_error$message4 = error.message) !== null && _error$message4 !== void 0 && _error$message4.includes('insufficient balance')) {\n        errorMessage = error.message;\n      } else if ((_error$message5 = error.message) !== null && _error$message5 !== void 0 && _error$message5.includes('paused')) {\n        errorMessage = error.message;\n      } else if (error.code === -32603) {\n        errorMessage = 'Network error - please try again';\n      }\n      toast.error(errorMessage);\n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n  async getPlayerStats(address) {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n    try {\n      const stats = await this.contract.getPlayerStats(address);\n\n      // The contract returns individual values\n      const totalGames = Number(stats[0]);\n      const totalWins = Number(stats[1]);\n      const totalWagered = ethers.formatEther(stats[2]);\n      const totalWon = ethers.formatEther(stats[3]);\n      return {\n        totalGames,\n        totalWins,\n        winRate: totalGames > 0 ? totalWins / totalGames * 100 : 0,\n        totalWagered,\n        totalWon,\n        netProfit: (parseFloat(totalWon) - parseFloat(totalWagered)).toString()\n      };\n    } catch (error) {\n      console.error('Error fetching player stats:', error);\n      // Return default stats instead of null to prevent UI issues\n      return {\n        totalGames: 0,\n        totalWins: 0,\n        winRate: 0,\n        totalWagered: '0',\n        totalWon: '0',\n        netProfit: '0'\n      };\n    }\n  }\n  async getRecentGames(limit = 50) {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n    try {\n      const games = await this.contract.getRecentGames();\n      return games.slice(0, limit).map((game, index) => ({\n        id: `${game.player}-${game.timestamp}-${index}`,\n        player: game.player,\n        betAmount: ethers.formatEther(game.betAmount),\n        choice: game.choice ? 'heads' : 'tails',\n        result: game.result ? 'heads' : 'tails',\n        won: game.won,\n        payout: ethers.formatEther(game.payout),\n        timestamp: Number(game.timestamp),\n        txHash: '' // This would need to be tracked separately or obtained from events\n      }));\n    } catch (error) {\n      console.error('Error fetching recent games:', error);\n      return [];\n    }\n  }\n  async getGameStats() {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n    try {\n      const stats = await this.contract.getGameStats();\n\n      // The new contract returns individual values, not a struct\n      return {\n        totalGames: Number(stats[0]),\n        totalVolume: ethers.formatEther(stats[1]),\n        totalPayout: ethers.formatEther(stats[2]),\n        activeUsers: Number(stats[3])\n      };\n    } catch (error) {\n      console.error('Error fetching game stats:', error);\n      return null;\n    }\n  }\n  async getLeaderboard(limit = 10) {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n    try {\n      const [players, wins, wagered] = await this.contract.getTopPlayers(limit);\n      return players.map((player, index) => ({\n        address: player,\n        wins: Number(wins[index]),\n        totalWagered: ethers.formatEther(wagered[index]),\n        netProfit: '0',\n        // Would need additional calculation\n        winRate: 0 // Would need total games to calculate\n      }));\n    } catch (error) {\n      console.error('Error fetching leaderboard:', error);\n      return [];\n    }\n  }\n  async waitForTransaction(txHash) {\n    if (!this.provider) return false;\n    try {\n      const receipt = await this.provider.waitForTransaction(txHash, 1, 30000); // 30 second timeout\n      return receipt ? receipt.status === 1 : false;\n    } catch (error) {\n      console.error('Error waiting for transaction:', error);\n      return false;\n    }\n  }\n\n  // Utility method to parse game events (for real-time updates)\n  async parseGameEvents(fromBlock = 0) {\n    if (!this.contract || !this.provider) return [];\n    try {\n      // This would parse GamePlayed events from the contract\n      // Implementation depends on the actual contract events\n      const filter = this.contract.filters.GamePlayed();\n      const events = await this.contract.queryFilter(filter, fromBlock);\n      return events.map(event => {\n        const args = event.args;\n        return {\n          id: `${args.player}-${args.timestamp}`,\n          player: args.player,\n          betAmount: ethers.formatEther(args.betAmount),\n          choice: args.choice ? 'heads' : 'tails',\n          result: args.result ? 'heads' : 'tails',\n          won: args.won,\n          payout: ethers.formatEther(args.payout),\n          timestamp: Number(args.timestamp),\n          txHash: event.transactionHash\n        };\n      });\n    } catch (error) {\n      console.error('Error parsing game events:', error);\n      return [];\n    }\n  }\n\n  // Listen for real-time game events\n  setupEventListeners(onGamePlayed) {\n    if (!this.contract) {\n      return () => {};\n    }\n    const handleGamePlayed = (player, betAmount, choice, result, won, payout, timestamp) => {\n      const game = {\n        id: `${player}-${timestamp}`,\n        player,\n        betAmount: ethers.formatEther(betAmount),\n        choice: choice ? 'heads' : 'tails',\n        result: result ? 'heads' : 'tails',\n        won,\n        payout: ethers.formatEther(payout),\n        timestamp: Number(timestamp),\n        txHash: '' // Would be available in the event context\n      };\n      if (onGamePlayed) {\n        onGamePlayed(game);\n      }\n    };\n    try {\n      this.contract.on('GamePlayed', handleGamePlayed);\n      return () => {\n        if (this.contract) {\n          this.contract.off('GamePlayed', handleGamePlayed);\n        }\n      };\n    } catch (error) {\n      console.error('Error setting up event listeners:', error);\n      return () => {};\n    }\n  }\n  disconnect() {\n    if (this.contract) {\n      this.contract.removeAllListeners();\n    }\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n  }\n\n  // Helper method to parse game result from transaction receipt\n  async parseGameResultFromReceipt(receipt) {\n    if (!this.contract) return null;\n    try {\n      // Look for GamePlayed events in the receipt\n      const logs = receipt.logs;\n      for (const log of logs) {\n        try {\n          const parsedLog = this.contract.interface.parseLog(log);\n          if (parsedLog && parsedLog.name === 'GamePlayed') {\n            return {\n              won: parsedLog.args.won,\n              betAmount: parsedLog.args.betAmount,\n              payout: parsedLog.args.payout\n            };\n          }\n        } catch (e) {\n          // Skip logs that don't match our contract interface\n          continue;\n        }\n      }\n      return null;\n    } catch (error) {\n      console.error('Error parsing game result from receipt:', error);\n      return null;\n    }\n  }\n}\n\n// Singleton instance\nexport const contractService = new ContractService();","map":{"version":3,"names":["ethers","CONTRACT_ABI","SHARDEUM_UNSTABLE","apiService","toast","ContractService","constructor","provider","signer","contract","initialize","Contract","contracts","shardFlip","isInitialized","flipCoin","amount","choice","success","error","betAmount","parseEther","choiceBool","betInfo","parseFloat","player","getAddress","minBet","MIN_BET","Error","formatEther","maxBet","MAX_BET","contractBalance","getContractBalance","payoutMultiplier","PAYOUT_MULTIPLIER","potentialPayout","BigInt","isPaused","paused","gasLimit","gasEstimate","estimateGas","value","gasError","console","warn","txOptions","feeData","getFeeData","gasPrice","tx","receipt","wait","status","gameResult","parseGameResultFromReceipt","playerAddress","log","Promise","resolve","setTimeout","won","payout","result","updateGameResult","recentGames","getRecentGames","playerGame","find","game","toLowerCase","Math","abs","contractError","backendError","url","process","env","REACT_APP_API_URL","hasApiKey","REACT_APP_API_SECRET_KEY","txHash","hash","_error$message","_error$message2","_error$message3","_error$message4","_error$message5","message","code","reason","data","errorMessage","includes","getPlayerStats","address","stats","totalGames","Number","totalWins","totalWagered","totalWon","winRate","netProfit","toString","limit","games","slice","map","index","id","timestamp","getGameStats","totalVolume","totalPayout","activeUsers","getLeaderboard","players","wins","wagered","getTopPlayers","waitForTransaction","parseGameEvents","fromBlock","filter","filters","GamePlayed","events","queryFilter","event","args","transactionHash","setupEventListeners","onGamePlayed","handleGamePlayed","on","off","disconnect","removeAllListeners","logs","parsedLog","interface","parseLog","name","e","contractService"],"sources":["/Users/nikhilkumar/Documents/Unstable/Shard-Flip/src/services/contractService.ts"],"sourcesContent":["import { ethers } from 'ethers';\nimport { GameResult, PlayerStats, GameStats, LeaderboardEntry, CoinSide } from '../types';\nimport { CONTRACT_ABI, SHARDEUM_UNSTABLE } from '../utils/constants';\nimport { apiService } from './apiService';\nimport toast from 'react-hot-toast';\n\nexport class ContractService {\n  private contract: ethers.Contract | null = null;\n  private provider: ethers.BrowserProvider | null = null;\n  private signer: ethers.JsonRpcSigner | null = null;\n\n  constructor(provider?: ethers.BrowserProvider, signer?: ethers.JsonRpcSigner) {\n    if (provider && signer) {\n      this.initialize(provider, signer);\n    }\n  }\n\n  initialize(provider: ethers.BrowserProvider, signer: ethers.JsonRpcSigner) {\n    this.provider = provider;\n    this.signer = signer;\n    this.contract = new ethers.Contract(\n      SHARDEUM_UNSTABLE.contracts.shardFlip,\n      CONTRACT_ABI,\n      signer\n    );\n  }\n\n  isInitialized(): boolean {\n    return this.contract !== null && this.signer !== null && this.provider !== null;\n  }\n\n  async flipCoin(amount: string, choice: CoinSide): Promise<{ success: boolean; txHash?: string; error?: string }> {\n    if (!this.isInitialized()) {\n      return { success: false, error: 'Contract not initialized' };\n    }\n\n    try {\n      const betAmount = ethers.parseEther(amount);\n      const choiceBool = choice === 'heads'; // true for heads, false for tails\n      \n      // Store bet info for fallback update\n      const betInfo = {\n        amount: parseFloat(amount),\n        choice: choice,\n        player: this.signer ? await this.signer.getAddress() : null\n      };\n\n      // Check minimum bet amount\n      const minBet = await this.contract!.MIN_BET();\n      if (betAmount < minBet) {\n        throw new Error(`Minimum bet is ${ethers.formatEther(minBet)} SHM`);\n      }\n\n      // Check maximum bet amount\n      const maxBet = await this.contract!.MAX_BET();\n      if (betAmount > maxBet) {\n        throw new Error(`Maximum bet is ${ethers.formatEther(maxBet)} SHM`);\n      }\n\n      // Check contract balance for potential payout\n      const contractBalance = await this.contract!.getContractBalance();\n      const payoutMultiplier = await this.contract!.PAYOUT_MULTIPLIER();\n      const potentialPayout = betAmount * payoutMultiplier / BigInt(100);\n      \n      if (contractBalance < potentialPayout) {\n        throw new Error('Contract has insufficient balance for this bet');\n      }\n\n      // Check if contract is paused\n      const isPaused = await this.contract!.paused();\n      if (isPaused) {\n        throw new Error('Contract is currently paused');\n      }\n\n      let gasLimit;\n      try {\n        // Estimate gas with a more conservative approach\n        const gasEstimate = await this.contract!.flipCoin.estimateGas(choiceBool, {\n          value: betAmount\n        });\n        gasLimit = gasEstimate * BigInt(150) / BigInt(100); // 50% buffer\n      } catch (gasError) {\n        console.warn('Gas estimation failed, using fallback:', gasError);\n        gasLimit = BigInt(500000); // Fallback gas limit\n      }\n\n      // Get current gas price with fallback for networks that don't support EIP-1559\n      let txOptions: any = {\n        value: betAmount,\n        gasLimit: gasLimit\n      };\n\n      try {\n        const feeData = await this.provider!.getFeeData();\n        if (feeData.gasPrice) {\n          txOptions.gasPrice = feeData.gasPrice;\n        }\n      } catch (gasError) {\n        console.warn('Failed to get fee data, using default gas settings:', gasError);\n      }\n\n      const tx = await this.contract!.flipCoin(choiceBool, txOptions);\n\n      toast.success('Transaction sent! Waiting for confirmation...');\n      \n      const receipt = await tx.wait();\n      \n      if (receipt && receipt.status === 1) {\n        toast.success('Coin flip completed!');\n        \n        // Get the game result from transaction receipt\n        const gameResult = await this.parseGameResultFromReceipt(receipt);\n        \n        // Always attempt backend update after successful transaction\n        if (this.signer) {\n          const playerAddress = await this.signer.getAddress();\n          console.log('🎮 Updating backend for successful game by:', playerAddress);\n          console.log('💰 Bet amount:', betInfo.amount, 'SHM');\n          \n          try {\n            // First, get the actual game result from the blockchain\n            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2s for blockchain to update\n            \n            if (gameResult) {\n              console.log('📊 Parsed game result:', {\n                won: gameResult.won,\n                betAmount: ethers.formatEther(gameResult.betAmount),\n                payout: ethers.formatEther(gameResult.payout)\n              });\n              \n              const result = await apiService.updateGameResult(\n                playerAddress,\n                gameResult.won ? 'win' : 'loss',\n                parseFloat(ethers.formatEther(gameResult.betAmount)),\n                gameResult.won ? parseFloat(ethers.formatEther(gameResult.payout)) : 0\n              );\n              console.log('✅ Backend update result:', result);\n            } else {\n              console.log('⚠️ Could not parse game result from receipt, checking contract directly...');\n              \n              // Fallback: Check contract for recent games\n              try {\n                const recentGames = await this.getRecentGames(5);\n                const playerGame = recentGames.find(game => \n                  game.player.toLowerCase() === playerAddress.toLowerCase() &&\n                  Math.abs(parseFloat(game.betAmount) - betInfo.amount) < 0.001\n                );\n                \n                if (playerGame) {\n                  console.log('🎯 Found matching game in contract:', playerGame);\n                  const result = await apiService.updateGameResult(\n                    playerAddress,\n                    playerGame.won ? 'win' : 'loss',\n                    parseFloat(playerGame.betAmount),\n                    parseFloat(playerGame.payout)\n                  );\n                  console.log('✅ Backend updated from contract data:', result);\n                } else {\n                  console.log('🔍 No matching game found, using bet amount as fallback');\n                  // Last resort: assume loss if we can't determine result\n                  const result = await apiService.updateGameResult(\n                    playerAddress,\n                    'loss', // Conservative assumption\n                    betInfo.amount,\n                    0\n                  );\n                  console.log('✅ Backend updated with fallback (assumed loss):', result);\n                }\n              } catch (contractError) {\n                console.error('Failed to get game from contract:', contractError);\n              }\n            }\n          } catch (backendError) {\n            console.error('❌ Failed to update backend:', backendError);\n            console.log('🔧 Backend error details:', {\n              url: process.env.REACT_APP_API_URL,\n              hasApiKey: !!process.env.REACT_APP_API_SECRET_KEY\n            });\n          }\n        }\n        \n        return { success: true, txHash: tx.hash };\n      } else {\n        throw new Error('Transaction failed');\n      }\n\n    } catch (error: any) {\n      console.error('❌ Error flipping coin:', error);\n      console.error('❌ Error details:', {\n        message: error.message,\n        code: error.code,\n        reason: error.reason,\n        data: error.data\n      });\n\n      let errorMessage = 'Failed to flip coin';\n      \n      if (error.code === 'ACTION_REJECTED') {\n        errorMessage = 'Transaction rejected by user';\n      } else if (error.code === 'INSUFFICIENT_FUNDS') {\n        errorMessage = 'Insufficient funds for bet + gas';\n      } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {\n        errorMessage = 'Cannot estimate gas - contract may be paused or have insufficient balance';\n      } else if (error.message?.includes('insufficient funds')) {\n        errorMessage = 'Insufficient SHM balance';\n      } else if (error.message?.includes('Minimum bet')) {\n        errorMessage = error.message;\n      } else if (error.message?.includes('Maximum bet')) {\n        errorMessage = error.message;\n      } else if (error.message?.includes('insufficient balance')) {\n        errorMessage = error.message;\n      } else if (error.message?.includes('paused')) {\n        errorMessage = error.message;\n      } else if (error.code === -32603) {\n        errorMessage = 'Network error - please try again';\n      }\n\n      toast.error(errorMessage);\n      return { success: false, error: errorMessage };\n    }\n  }\n\n  async getPlayerStats(address: string): Promise<PlayerStats | null> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n\n    try {\n      const stats = await this.contract!.getPlayerStats(address);\n      \n      // The contract returns individual values\n      const totalGames = Number(stats[0]);\n      const totalWins = Number(stats[1]);\n      const totalWagered = ethers.formatEther(stats[2]);\n      const totalWon = ethers.formatEther(stats[3]);\n\n      return {\n        totalGames,\n        totalWins,\n        winRate: totalGames > 0 ? (totalWins / totalGames) * 100 : 0,\n        totalWagered,\n        totalWon,\n        netProfit: (parseFloat(totalWon) - parseFloat(totalWagered)).toString()\n      };\n\n    } catch (error) {\n      console.error('Error fetching player stats:', error);\n      // Return default stats instead of null to prevent UI issues\n      return {\n        totalGames: 0,\n        totalWins: 0,\n        winRate: 0,\n        totalWagered: '0',\n        totalWon: '0',\n        netProfit: '0'\n      };\n    }\n  }\n\n  async getRecentGames(limit: number = 50): Promise<GameResult[]> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n\n    try {\n      const games = await this.contract!.getRecentGames();\n      \n      return games.slice(0, limit).map((game: any, index: number) => ({\n        id: `${game.player}-${game.timestamp}-${index}`,\n        player: game.player,\n        betAmount: ethers.formatEther(game.betAmount),\n        choice: game.choice ? 'heads' : 'tails',\n        result: game.result ? 'heads' : 'tails',\n        won: game.won,\n        payout: ethers.formatEther(game.payout),\n        timestamp: Number(game.timestamp),\n        txHash: '' // This would need to be tracked separately or obtained from events\n      }));\n\n    } catch (error) {\n      console.error('Error fetching recent games:', error);\n      return [];\n    }\n  }\n\n  async getGameStats(): Promise<GameStats | null> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return null;\n    }\n\n    try {\n      const stats = await this.contract!.getGameStats();\n      \n      // The new contract returns individual values, not a struct\n      return {\n        totalGames: Number(stats[0]),\n        totalVolume: ethers.formatEther(stats[1]),\n        totalPayout: ethers.formatEther(stats[2]),\n        activeUsers: Number(stats[3])\n      };\n\n    } catch (error) {\n      console.error('Error fetching game stats:', error);\n      return null;\n    }\n  }\n\n  async getLeaderboard(limit: number = 10): Promise<LeaderboardEntry[]> {\n    if (!this.isInitialized()) {\n      console.error('Contract not initialized');\n      return [];\n    }\n\n    try {\n      const [players, wins, wagered] = await this.contract!.getTopPlayers(limit);\n      \n      return players.map((player: string, index: number) => ({\n        address: player,\n        wins: Number(wins[index]),\n        totalWagered: ethers.formatEther(wagered[index]),\n        netProfit: '0', // Would need additional calculation\n        winRate: 0 // Would need total games to calculate\n      }));\n    } catch (error) {\n      console.error('Error fetching leaderboard:', error);\n      return [];\n    }\n  }\n\n  async waitForTransaction(txHash: string): Promise<boolean> {\n    if (!this.provider) return false;\n\n    try {\n      const receipt = await this.provider.waitForTransaction(txHash, 1, 30000); // 30 second timeout\n      return receipt ? receipt.status === 1 : false;\n    } catch (error) {\n      console.error('Error waiting for transaction:', error);\n      return false;\n    }\n  }\n\n  // Utility method to parse game events (for real-time updates)\n  async parseGameEvents(fromBlock: number = 0): Promise<GameResult[]> {\n    if (!this.contract || !this.provider) return [];\n\n    try {\n      // This would parse GamePlayed events from the contract\n      // Implementation depends on the actual contract events\n      const filter = this.contract.filters.GamePlayed();\n      const events = await this.contract.queryFilter(filter, fromBlock);\n      \n      return events.map((event: any) => {\n        const args = event.args;\n        return {\n          id: `${args.player}-${args.timestamp}`,\n          player: args.player,\n          betAmount: ethers.formatEther(args.betAmount),\n          choice: args.choice ? 'heads' : 'tails',\n          result: args.result ? 'heads' : 'tails',\n          won: args.won,\n          payout: ethers.formatEther(args.payout),\n          timestamp: Number(args.timestamp),\n          txHash: event.transactionHash\n        };\n      });\n\n    } catch (error) {\n      console.error('Error parsing game events:', error);\n      return [];\n    }\n  }\n\n  // Listen for real-time game events\n  setupEventListeners(onGamePlayed?: (game: GameResult) => void): () => void {\n    if (!this.contract) {\n      return () => {};\n    }\n\n    const handleGamePlayed = (player: string, betAmount: bigint, choice: boolean, result: boolean, won: boolean, payout: bigint, timestamp: bigint) => {\n      const game: GameResult = {\n        id: `${player}-${timestamp}`,\n        player,\n        betAmount: ethers.formatEther(betAmount),\n        choice: choice ? 'heads' : 'tails',\n        result: result ? 'heads' : 'tails',\n        won,\n        payout: ethers.formatEther(payout),\n        timestamp: Number(timestamp),\n        txHash: '' // Would be available in the event context\n      };\n\n      if (onGamePlayed) {\n        onGamePlayed(game);\n      }\n    };\n\n    try {\n      this.contract.on('GamePlayed', handleGamePlayed);\n      \n      return () => {\n        if (this.contract) {\n          this.contract.off('GamePlayed', handleGamePlayed);\n        }\n      };\n    } catch (error) {\n      console.error('Error setting up event listeners:', error);\n      return () => {};\n    }\n  }\n\n  disconnect() {\n    if (this.contract) {\n      this.contract.removeAllListeners();\n    }\n    this.contract = null;\n    this.provider = null;\n    this.signer = null;\n  }\n\n  // Helper method to parse game result from transaction receipt\n  private async parseGameResultFromReceipt(receipt: any): Promise<{ won: boolean; betAmount: bigint; payout: bigint } | null> {\n    if (!this.contract) return null;\n\n    try {\n      // Look for GamePlayed events in the receipt\n      const logs = receipt.logs;\n      \n      for (const log of logs) {\n        try {\n          const parsedLog = this.contract.interface.parseLog(log);\n          if (parsedLog && parsedLog.name === 'GamePlayed') {\n            return {\n              won: parsedLog.args.won,\n              betAmount: parsedLog.args.betAmount,\n              payout: parsedLog.args.payout\n            };\n          }\n        } catch (e) {\n          // Skip logs that don't match our contract interface\n          continue;\n        }\n      }\n      \n      return null;\n    } catch (error) {\n      console.error('Error parsing game result from receipt:', error);\n      return null;\n    }\n  }\n}\n\n// Singleton instance\nexport const contractService = new ContractService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}